const O = [
  "/internal/immutable/assets/fira-mono-cyrillic-ext-400-normal-3df7909e.woff2",
  "/internal/immutable/assets/fira-mono-cyrillic-400-normal-c7d433fd.woff2",
  "/internal/immutable/assets/fira-mono-greek-ext-400-normal-9e2fe623.woff2",
  "/internal/immutable/assets/fira-mono-greek-400-normal-a8be01ce.woff2",
  "/internal/immutable/assets/fira-mono-latin-ext-400-normal-6bfabd30.woff2",
  "/internal/immutable/assets/fira-mono-latin-400-normal-e43b3538.woff2",
  "/internal/immutable/assets/fira-mono-all-400-normal-1e3b098c.woff",
  "/internal/immutable/assets/sk-c8852f92.jpg",
  "/internal/immutable/assets/sk-706ac9fe.webp",
  "/internal/immutable/assets/Dusza-mobil-2021-107b44e5.webp",
  "/internal/immutable/assets/Dusza-mobil-2020-7b1e11f8.webp",
  "/internal/immutable/assets/Dusza-mobil-2019-e0d3b031.webp",
  "/internal/immutable/assets/Ifju-Tudosok-2022-4389b3bc.webp",
  "/internal/immutable/assets/Merklik-2021-faccd106.webp",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2021-b1cc32b2.webp",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2021-89e298c2.webp",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2021-f6cd611e.webp",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2020-95189328.webp",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2020-6d5ca2ad.webp",
  "/internal/immutable/assets/SZIIV-2020-06406d7e.webp",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2020-13f68239.webp",
  "/internal/immutable/assets/Webex-Teams-Hackathlon-2019-photo-ba6c1a2a.webp",
  "/internal/immutable/assets/Dusza-2020-1b56d4b0.webp",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2019-e34ace99.webp",
  "/internal/immutable/assets/SZIIV-2019-d986bf56.webp",
  "/internal/immutable/assets/Dusza-2019-ad68845c.webp",
  "/internal/immutable/assets/Skills-Junior-Web-2022-607b0efc.webp",
  "/internal/immutable/assets/Iskola-programozas-verseny-2018-1e3e274c.webp",
  "/internal/immutable/assets/Nemes-Tihamer-2019-6b82fe06.webp",
  "/internal/immutable/assets/Dusza-mobil-2021-1099f730.jpg",
  "/internal/immutable/assets/Dusza-mobil-2019-2c39fa70.jpg",
  "/internal/immutable/assets/Dusza-mobil-2020-a8e82388.jpg",
  "/internal/immutable/assets/Merklik-2021-400e93d3.jpg",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2021-b5676f16.jpg",
  "/internal/immutable/assets/Ifju-Tudosok-2022-28902e66.jpg",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2021-307778ff.jpg",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2020-a33151ad.jpg",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2021-67f79f7c.jpg",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2020-52ea43a0.jpg",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2020-a54a8bf9.jpg",
  "/internal/immutable/assets/Dusza-2020-a2277c96.jpg",
  "/internal/immutable/assets/SZIIV-2020-97c79f2f.jpg",
  "/internal/immutable/assets/Webex-Teams-Hackathlon-2019-photo-54e6a713.jpg",
  "/internal/immutable/assets/Skills-Junior-Web-2022-fa2a2006.jpg",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2019-783a2eb2.jpg",
  "/internal/immutable/assets/Dusza-2019-d577e7ef.jpg",
  "/internal/immutable/assets/SZIIV-2019-7c0e8d8f.jpg",
  "/internal/immutable/assets/Iskola-programozas-verseny-2018-2bcab67d.jpg",
  "/internal/immutable/assets/Nemes-Tihamer-2019-0babb42a.jpg",
  "/internal/immutable/assets/ASZEV2022-8a7b693b.webp",
  "/internal/immutable/assets/ASZEV2022-bcc53251.jpg",
  "/internal/immutable/start-a3e68af2.js",
  "/internal/immutable/pages/__layout.svelte-01e1a688.js",
  "/internal/immutable/error.svelte-ba70b162.js",
  "/internal/immutable/pages/__layout-min.svelte-813bd829.js",
  "/internal/immutable/assets/app-51826010.css",
  "/internal/immutable/pages/__layout-web.svelte-4f0a46b6.js",
  "/internal/immutable/assets/__layout-web-138e1b49.css",
  "/internal/immutable/pages/404@web.svelte-fb346653.js",
  "/internal/immutable/assets/404@web-42a5e5d1.css",
  "/internal/immutable/pages/index@web.svelte-1296a864.js",
  "/internal/immutable/assets/index@web-50378ec7.css",
  "/internal/immutable/pages/me-card-wrapped.svelte-bcf04fa8.js",
  "/internal/immutable/pages/me@min.svelte-5928adb2.js",
  "/internal/immutable/assets/me@min-4ff9918c.css",
  "/internal/immutable/pages/posts/_post_@web.svelte-9d86b593.js",
  "/internal/immutable/pages/posts@web.svelte-b4364c14.js",
  "/internal/immutable/assets/posts@web-e0148492.css",
  "/internal/immutable/chunks/index-63d179ed.js",
  "/internal/immutable/chunks/preload-helper-30e8f224.js",
  "/internal/immutable/chunks/layout-helper-c7a27558.js",
  "/internal/immutable/chunks/service-95f68a5c.js",
  "/internal/immutable/assets/service-60614438.css",
  "/internal/immutable/chunks/Face-8d009a19.js",
  "/internal/immutable/chunks/IconBase-35237b9e.js",
  "/internal/immutable/assets/IconBase-6bf551a2.css",
  "/internal/immutable/chunks/FaEnvelope-c9851864.js",
  "/internal/immutable/chunks/MeCard-954f0439.js",
  "/internal/immutable/assets/MeCard-fc36dd26.css",
  "/internal/immutable/chunks/index-056b5e13.js",
  "/internal/immutable/chunks/loopTypewriter-9662c409.js",
  "/internal/immutable/chunks/writeEffect-6c629c6d.js",
  "/internal/immutable/chunks/sleep-c89e9a38.js",
  "/internal/immutable/chunks/scramble-675c3d15.js",
  "/internal/immutable/chunks/typewriter-0f489855.js",
  "/internal/immutable/chunks/pathseg-64c2e5a9.js",
  "/internal/immutable/chunks/emojik-es-a-windows-555492b9.js",
  "/internal/immutable/chunks/_post-887d8481.js",
  "/internal/immutable/assets/_post-2c05d00e.css",
  "/internal/immutable/chunks/hidden-post-ff0a2c42.js",
  "/internal/immutable/chunks/welcome-99d49286.js",
  "/internal/immutable/chunks/getLongestTextElement-c055ee71.js",
  "/internal/immutable/chunks/giscus.es-4bdaf6f4.js"
], L = [
  "/.nojekyll",
  "/android-chrome-192x192.png",
  "/android-chrome-512x512.png",
  "/apple-touch-icon.png",
  "/assets/card/windmill.svg",
  "/assets/certificates/CCNA-1-certificate.pdf",
  "/assets/certificates/CCNA-2-certificate.pdf",
  "/assets/competitions/ASZEV2022.jpeg",
  "/assets/competitions/Accenture Java 2020.pdf",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.jpeg",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.jpeg",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.jpeg",
  "/assets/competitions/Dusza-2019.jpeg",
  "/assets/competitions/Dusza-2020.jpeg",
  "/assets/competitions/Dusza-mobil-2019.jpeg",
  "/assets/competitions/Dusza-mobil-2020.jpeg",
  "/assets/competitions/Dusza-mobil-2021.jpeg",
  "/assets/competitions/GAMF programoz\xF3 verseny 2020.pdf",
  "/assets/competitions/Ifju-Tudosok-2022.jpeg",
  "/assets/competitions/Innovacios-tehetsegkutato-2020.jpeg",
  "/assets/competitions/Innovacios-tehetsegkutato-2021.jpeg",
  "/assets/competitions/Iskola-programozas-verseny-2018.jpeg",
  "/assets/competitions/Kodolj-Hatarok-Nelkul-2020.jpeg",
  "/assets/competitions/Kodolj-Hatarok-Nelkul-2021.jpeg",
  "/assets/competitions/Merklik-2021.jpeg",
  "/assets/competitions/Nemes-Tihamer-2019.jpeg",
  "/assets/competitions/Nemes-Tihamer-2020.pdf",
  "/assets/competitions/SZIIV-2019.jpeg",
  "/assets/competitions/SZIIV-2020.jpeg",
  "/assets/competitions/Skills-Junior-Web-2022.jpeg",
  "/assets/competitions/Webex-Teams-Hackathlon-2019-photo.jpeg",
  "/assets/og-banner.jpg",
  "/assets/people/sk.jpeg",
  "/assets/people/unknownhe.jpeg",
  "/assets/posts/yt1f9UbfqqHlknfx-image-1653148385384.png",
  "/favicon-16x16.png",
  "/favicon-32x32.png",
  "/favicon.ico",
  "/manifest.json",
  "/robots.txt"
], P = [
  "/404",
  "/shlinks/---404.txt",
  "/",
  "/shlinks/---.txt",
  "/me-card-wrapped",
  "/me",
  "/shlinks/---me.txt",
  "/posts",
  "/shlinks/---posts.txt",
  "/sitemap.xml",
  "/rss.xml",
  "/posts/emojik-es-a-windows",
  "/shlinks/---posts---emojik-es-a-windows.txt",
  "/posts/hidden-post",
  "/shlinks/---posts---hidden-post.txt",
  "/posts/welcome",
  "/shlinks/---posts---welcome.txt",
  "/business-card-front.svg",
  "/business-card-back.svg"
], V = "1659941029330";
try {
  self["workbox:core:6.5.2"] && _();
} catch {
}
const q = {
  "invalid-value": ({ paramName: s, validValueDescription: e, value: t }) => {
    if (!s || !e)
      throw new Error("Unexpected input to 'invalid-value' error.");
    return `The '${s}' parameter was given a value with an unexpected value. ${e} Received a value of ${JSON.stringify(t)}.`;
  },
  "not-an-array": ({ moduleName: s, className: e, funcName: t, paramName: a }) => {
    if (!s || !e || !t || !a)
      throw new Error("Unexpected input to 'not-an-array' error.");
    return `The parameter '${a}' passed into '${s}.${e}.${t}()' must be an array.`;
  },
  "incorrect-type": ({ expectedType: s, paramName: e, moduleName: t, className: a, funcName: n }) => {
    if (!s || !e || !t || !n)
      throw new Error("Unexpected input to 'incorrect-type' error.");
    const r = a ? `${a}.` : "";
    return `The parameter '${e}' passed into '${t}.${r}${n}()' must be of type ${s}.`;
  },
  "incorrect-class": ({ expectedClassName: s, paramName: e, moduleName: t, className: a, funcName: n, isReturnValueProblem: r }) => {
    if (!s || !t || !n)
      throw new Error("Unexpected input to 'incorrect-class' error.");
    const o = a ? `${a}.` : "";
    return r ? `The return value from '${t}.${o}${n}()' must be an instance of class ${s}.` : `The parameter '${e}' passed into '${t}.${o}${n}()' must be an instance of class ${s}.`;
  },
  "missing-a-method": ({ expectedMethod: s, paramName: e, moduleName: t, className: a, funcName: n }) => {
    if (!s || !e || !t || !a || !n)
      throw new Error("Unexpected input to 'missing-a-method' error.");
    return `${t}.${a}.${n}() expected the '${e}' parameter to expose a '${s}' method.`;
  },
  "add-to-cache-list-unexpected-type": ({ entry: s }) => `An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(s)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,
  "add-to-cache-list-conflicting-entries": ({ firstEntry: s, secondEntry: e }) => {
    if (!s || !e)
      throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");
    return `Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${s} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`;
  },
  "plugin-error-request-will-fetch": ({ thrownErrorMessage: s }) => {
    if (!s)
      throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");
    return `An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${s}'.`;
  },
  "invalid-cache-name": ({ cacheNameId: s, value: e }) => {
    if (!s)
      throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");
    return `You must provide a name containing at least one character for setCacheDetails({${s}: '...'}). Received a value of '${JSON.stringify(e)}'`;
  },
  "unregister-route-but-not-found-with-method": ({ method: s }) => {
    if (!s)
      throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");
    return `The route you're trying to unregister was not  previously registered for the method type '${s}'.`;
  },
  "unregister-route-route-not-registered": () => "The route you're trying to unregister was not previously registered.",
  "queue-replay-failed": ({ name: s }) => `Replaying the background sync queue '${s}' failed.`,
  "duplicate-queue-name": ({ name: s }) => `The Queue name '${s}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,
  "expired-test-without-max-age": ({ methodName: s, paramName: e }) => `The '${s}()' method can only be used when the '${e}' is used in the constructor.`,
  "unsupported-route-type": ({ moduleName: s, className: e, funcName: t, paramName: a }) => `The supplied '${a}' parameter was an unsupported type. Please check the docs for ${s}.${e}.${t} for valid input types.`,
  "not-array-of-class": ({ value: s, expectedClass: e, moduleName: t, className: a, funcName: n, paramName: r }) => `The supplied '${r}' parameter must be an array of '${e}' objects. Received '${JSON.stringify(s)},'. Please check the call to ${t}.${a}.${n}() to fix the issue.`,
  "max-entries-or-age-required": ({ moduleName: s, className: e, funcName: t }) => `You must define either config.maxEntries or config.maxAgeSecondsin ${s}.${e}.${t}`,
  "statuses-or-headers-required": ({ moduleName: s, className: e, funcName: t }) => `You must define either config.statuses or config.headersin ${s}.${e}.${t}`,
  "invalid-string": ({ moduleName: s, funcName: e, paramName: t }) => {
    if (!t || !s || !e)
      throw new Error("Unexpected input to 'invalid-string' error.");
    return `When using strings, the '${t}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${s}.${e}() for more info.`;
  },
  "channel-name-required": () => "You must provide a channelName to construct a BroadcastCacheUpdate instance.",
  "invalid-responses-are-same-args": () => "The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.",
  "expire-custom-caches-only": () => "You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.",
  "unit-must-be-bytes": ({ normalizedRangeHeader: s }) => {
    if (!s)
      throw new Error("Unexpected input to 'unit-must-be-bytes' error.");
    return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${s}"`;
  },
  "single-range-only": ({ normalizedRangeHeader: s }) => {
    if (!s)
      throw new Error("Unexpected input to 'single-range-only' error.");
    return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${s}"`;
  },
  "invalid-range-values": ({ normalizedRangeHeader: s }) => {
    if (!s)
      throw new Error("Unexpected input to 'invalid-range-values' error.");
    return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${s}"`;
  },
  "no-range-header": () => "No Range header was found in the Request provided.",
  "range-not-satisfiable": ({ size: s, start: e, end: t }) => `The start (${e}) and end (${t}) values in the Range are not satisfiable by the cached response, which is ${s} bytes.`,
  "attempt-to-cache-non-get-request": ({ url: s, method: e }) => `Unable to cache '${s}' because it is a '${e}' request and only 'GET' requests can be cached.`,
  "cache-put-with-no-response": ({ url: s }) => `There was an attempt to cache '${s}' but the response was not defined.`,
  "no-response": ({ url: s, error: e }) => {
    let t = `The strategy could not generate a response for '${s}'.`;
    return e && (t += ` The underlying error is ${e}.`), t;
  },
  "bad-precaching-response": ({ url: s, status: e }) => `The precaching request for '${s}' failed` + (e ? ` with an HTTP status of ${e}.` : "."),
  "non-precached-url": ({ url: s }) => `createHandlerBoundToURL('${s}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,
  "add-to-cache-list-conflicting-integrities": ({ url: s }) => `Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${s} with different integrity values. Please remove one of them.`,
  "missing-precache-entry": ({ cacheName: s, url: e }) => `Unable to find a precached response in ${s} for ${e}.`,
  "cross-origin-copy-response": ({ origin: s }) => `workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${s}.`,
  "opaque-streams-source": ({ type: s }) => {
    const e = `One of the workbox-streams sources resulted in an '${s}' response.`;
    return s === "opaqueredirect" ? `${e} Please do not use a navigation request that results in a redirect as a source.` : `${e} Please ensure your sources are CORS-enabled.`;
  }
}, A = (s, ...e) => {
  let t = s;
  return e.length > 0 && (t += ` :: ${JSON.stringify(e)}`), t;
}, W = (s, e = {}) => {
  const t = q[s];
  if (!t)
    throw new Error(`Unable to find message for code '${s}'.`);
  return t(e);
}, B = process.env.NODE_ENV === "production" ? A : W;
class u extends Error {
  constructor(e, t) {
    const a = B(e, t);
    super(a), this.name = e, this.details = t;
  }
}
const M = (s, e) => {
  if (!Array.isArray(s))
    throw new u("not-an-array", e);
}, H = (s, e, t) => {
  if (typeof s[e] !== "function")
    throw t.expectedMethod = e, new u("missing-a-method", t);
}, F = (s, e, t) => {
  if (typeof s !== e)
    throw t.expectedType = e, new u("incorrect-type", t);
}, z = (s, e, t) => {
  if (!(s instanceof e))
    throw t.expectedClassName = e.name, new u("incorrect-class", t);
}, G = (s, e, t) => {
  if (!e.includes(s))
    throw t.validValueDescription = `Valid values are ${JSON.stringify(e)}.`, new u("invalid-value", t);
}, J = (s, e, t) => {
  const a = new u("not-array-of-class", t);
  if (!Array.isArray(s))
    throw a;
  for (const n of s)
    if (!(n instanceof e))
      throw a;
}, p = process.env.NODE_ENV === "production" ? null : {
  hasMethod: H,
  isArray: M,
  isInstance: z,
  isOneOf: G,
  isType: F,
  isArrayOfClass: J
}, m = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration < "u" ? registration.scope : ""
}, C = (s) => [m.prefix, s, m.suffix].filter((e) => e && e.length > 0).join("-"), Z = (s) => {
  for (const e of Object.keys(m))
    s(e);
}, v = {
  updateDetails: (s) => {
    Z((e) => {
      typeof s[e] == "string" && (m[e] = s[e]);
    });
  },
  getGoogleAnalyticsName: (s) => s || C(m.googleAnalytics),
  getPrecacheName: (s) => s || C(m.precache),
  getPrefix: () => m.prefix,
  getRuntimeName: (s) => s || C(m.runtime),
  getSuffix: () => m.suffix
}, c = process.env.NODE_ENV === "production" ? null : (() => {
  "__WB_DISABLE_DEV_LOGS" in self || (self.__WB_DISABLE_DEV_LOGS = !1);
  let s = !1;
  const e = {
    debug: "#7f8c8d",
    log: "#2ecc71",
    warn: "#f39c12",
    error: "#c0392b",
    groupCollapsed: "#3498db",
    groupEnd: null
  }, t = function(r, o) {
    if (self.__WB_DISABLE_DEV_LOGS)
      return;
    if (r === "groupCollapsed" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      console[r](...o);
      return;
    }
    const i = [
      `background: ${e[r]}`,
      "border-radius: 0.5em",
      "color: white",
      "font-weight: bold",
      "padding: 2px 0.5em"
    ], l = s ? [] : ["%cworkbox", i.join(";")];
    console[r](...l, ...o), r === "groupCollapsed" && (s = !0), r === "groupEnd" && (s = !1);
  }, a = {}, n = Object.keys(e);
  for (const r of n) {
    const o = r;
    a[o] = (...i) => {
      t(o, i);
    };
  }
  return a;
})();
function x(s, e) {
  const t = e();
  return s.waitUntil(t), t;
}
try {
  self["workbox:precaching:6.5.2"] && _();
} catch {
}
const Y = "__WB_REVISION__";
function Q(s) {
  if (!s)
    throw new u("add-to-cache-list-unexpected-type", { entry: s });
  if (typeof s == "string") {
    const r = new URL(s, location.href);
    return {
      cacheKey: r.href,
      url: r.href
    };
  }
  const { revision: e, url: t } = s;
  if (!t)
    throw new u("add-to-cache-list-unexpected-type", { entry: s });
  if (!e) {
    const r = new URL(t, location.href);
    return {
      cacheKey: r.href,
      url: r.href
    };
  }
  const a = new URL(t, location.href), n = new URL(t, location.href);
  return a.searchParams.set(Y, e), {
    cacheKey: a.href,
    url: n.href
  };
}
class X {
  constructor() {
    this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: t }) => {
      t && (t.originalRequest = e);
    }, this.cachedResponseWillBeUsed = async ({ event: e, state: t, cachedResponse: a }) => {
      if (e.type === "install" && t && t.originalRequest && t.originalRequest instanceof Request) {
        const n = t.originalRequest.url;
        a ? this.notUpdatedURLs.push(n) : this.updatedURLs.push(n);
      }
      return a;
    };
  }
}
class ee {
  constructor({ precacheController: e }) {
    this.cacheKeyWillBeUsed = async ({ request: t, params: a }) => {
      const n = (a == null ? void 0 : a.cacheKey) || this._precacheController.getCacheKeyForURL(t.url);
      return n ? new Request(n, { headers: t.headers }) : t;
    }, this._precacheController = e;
  }
}
const te = (s, e) => {
  c.groupCollapsed(s);
  for (const t of e)
    c.log(t);
  c.groupEnd();
};
function se(s) {
  const e = s.length;
  e > 0 && (c.groupCollapsed(`During precaching cleanup, ${e} cached request${e === 1 ? " was" : "s were"} deleted.`), te("Deleted Cache Requests", s), c.groupEnd());
}
function T(s, e) {
  if (e.length !== 0) {
    c.groupCollapsed(s);
    for (const t of e)
      c.log(t);
    c.groupEnd();
  }
}
function ae(s, e) {
  const t = s.length, a = e.length;
  if (t || a) {
    let n = `Precaching ${t} file${t === 1 ? "" : "s"}.`;
    a > 0 && (n += ` ${a} file${a === 1 ? " is" : "s are"} already cached.`), c.groupCollapsed(n), T("View newly precached URLs.", s), T("View previously precached URLs.", e), c.groupEnd();
  }
}
let y;
function ne() {
  if (y === void 0) {
    const s = new Response("");
    if ("body" in s)
      try {
        new Response(s.body), y = !0;
      } catch {
        y = !1;
      }
    y = !1;
  }
  return y;
}
async function re(s, e) {
  let t = null;
  if (s.url && (t = new URL(s.url).origin), t !== self.location.origin)
    throw new u("cross-origin-copy-response", { origin: t });
  const a = s.clone(), n = {
    headers: new Headers(a.headers),
    status: a.status,
    statusText: a.statusText
  }, r = e ? e(n) : n, o = ne() ? a.body : await a.blob();
  return new Response(o, r);
}
const h = (s) => new URL(String(s), location.href).href.replace(new RegExp(`^${location.origin}`), "");
function U(s, e) {
  const t = new URL(s);
  for (const a of e)
    t.searchParams.delete(a);
  return t.href;
}
async function oe(s, e, t, a) {
  const n = U(e.url, t);
  if (e.url === n)
    return s.match(e, a);
  const r = Object.assign(Object.assign({}, a), { ignoreSearch: !0 }), o = await s.keys(e, r);
  for (const i of o) {
    const l = U(i.url, t);
    if (n === l)
      return s.match(i, a);
  }
}
class ie {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
const D = /* @__PURE__ */ new Set();
async function ce() {
  process.env.NODE_ENV !== "production" && c.log(`About to run ${D.size} callbacks to clean up caches.`);
  for (const s of D)
    await s(), process.env.NODE_ENV !== "production" && c.log(s, "is complete.");
  process.env.NODE_ENV !== "production" && c.log("Finished running callbacks.");
}
function le(s) {
  return new Promise((e) => setTimeout(e, s));
}
try {
  self["workbox:strategies:6.5.2"] && _();
} catch {
}
function R(s) {
  return typeof s == "string" ? new Request(s) : s;
}
class ue {
  constructor(e, t) {
    this._cacheKeys = {}, process.env.NODE_ENV !== "production" && p.isInstance(t.event, ExtendableEvent, {
      moduleName: "workbox-strategies",
      className: "StrategyHandler",
      funcName: "constructor",
      paramName: "options.event"
    }), Object.assign(this, t), this.event = t.event, this._strategy = e, this._handlerDeferred = new ie(), this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const a of this._plugins)
      this._pluginStateMap.set(a, {});
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  async fetch(e) {
    const { event: t } = this;
    let a = R(e);
    if (a.mode === "navigate" && t instanceof FetchEvent && t.preloadResponse) {
      const o = await t.preloadResponse;
      if (o)
        return process.env.NODE_ENV !== "production" && c.log(`Using a preloaded navigation response for '${h(a.url)}'`), o;
    }
    const n = this.hasCallback("fetchDidFail") ? a.clone() : null;
    try {
      for (const o of this.iterateCallbacks("requestWillFetch"))
        a = await o({ request: a.clone(), event: t });
    } catch (o) {
      if (o instanceof Error)
        throw new u("plugin-error-request-will-fetch", {
          thrownErrorMessage: o.message
        });
    }
    const r = a.clone();
    try {
      let o;
      o = await fetch(a, a.mode === "navigate" ? void 0 : this._strategy.fetchOptions), process.env.NODE_ENV !== "production" && c.debug(`Network request for '${h(a.url)}' returned a response with status '${o.status}'.`);
      for (const i of this.iterateCallbacks("fetchDidSucceed"))
        o = await i({
          event: t,
          request: r,
          response: o
        });
      return o;
    } catch (o) {
      throw process.env.NODE_ENV !== "production" && c.log(`Network request for '${h(a.url)}' threw an error.`, o), n && await this.runCallbacks("fetchDidFail", {
        error: o,
        event: t,
        originalRequest: n.clone(),
        request: r.clone()
      }), o;
    }
  }
  async fetchAndCachePut(e) {
    const t = await this.fetch(e), a = t.clone();
    return this.waitUntil(this.cachePut(e, a)), t;
  }
  async cacheMatch(e) {
    const t = R(e);
    let a;
    const { cacheName: n, matchOptions: r } = this._strategy, o = await this.getCacheKey(t, "read"), i = Object.assign(Object.assign({}, r), { cacheName: n });
    a = await caches.match(o, i), process.env.NODE_ENV !== "production" && (a ? c.debug(`Found a cached response in '${n}'.`) : c.debug(`No cached response found in '${n}'.`));
    for (const l of this.iterateCallbacks("cachedResponseWillBeUsed"))
      a = await l({
        cacheName: n,
        matchOptions: r,
        cachedResponse: a,
        request: o,
        event: this.event
      }) || void 0;
    return a;
  }
  async cachePut(e, t) {
    const a = R(e);
    await le(0);
    const n = await this.getCacheKey(a, "write");
    if (process.env.NODE_ENV !== "production") {
      if (n.method && n.method !== "GET")
        throw new u("attempt-to-cache-non-get-request", {
          url: h(n.url),
          method: n.method
        });
      const d = t.headers.get("Vary");
      d && c.debug(`The response for ${h(n.url)} has a 'Vary: ${d}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);
    }
    if (!t)
      throw process.env.NODE_ENV !== "production" && c.error(`Cannot cache non-existent response for '${h(n.url)}'.`), new u("cache-put-with-no-response", {
        url: h(n.url)
      });
    const r = await this._ensureResponseSafeToCache(t);
    if (!r)
      return process.env.NODE_ENV !== "production" && c.debug(`Response '${h(n.url)}' will not be cached.`, r), !1;
    const { cacheName: o, matchOptions: i } = this._strategy, l = await self.caches.open(o), g = this.hasCallback("cacheDidUpdate"), b = g ? await oe(
      l,
      n.clone(),
      ["__WB_REVISION__"],
      i
    ) : null;
    process.env.NODE_ENV !== "production" && c.debug(`Updating the '${o}' cache with a new Response for ${h(n.url)}.`);
    try {
      await l.put(n, g ? r.clone() : r);
    } catch (d) {
      if (d instanceof Error)
        throw d.name === "QuotaExceededError" && await ce(), d;
    }
    for (const d of this.iterateCallbacks("cacheDidUpdate"))
      await d({
        cacheName: o,
        oldResponse: b,
        newResponse: r.clone(),
        request: n,
        event: this.event
      });
    return !0;
  }
  async getCacheKey(e, t) {
    const a = `${e.url} | ${t}`;
    if (!this._cacheKeys[a]) {
      let n = e;
      for (const r of this.iterateCallbacks("cacheKeyWillBeUsed"))
        n = R(await r({
          mode: t,
          request: n,
          event: this.event,
          params: this.params
        }));
      this._cacheKeys[a] = n;
    }
    return this._cacheKeys[a];
  }
  hasCallback(e) {
    for (const t of this._strategy.plugins)
      if (e in t)
        return !0;
    return !1;
  }
  async runCallbacks(e, t) {
    for (const a of this.iterateCallbacks(e))
      await a(t);
  }
  *iterateCallbacks(e) {
    for (const t of this._strategy.plugins)
      if (typeof t[e] == "function") {
        const a = this._pluginStateMap.get(t);
        yield (r) => {
          const o = Object.assign(Object.assign({}, r), { state: a });
          return t[e](o);
        };
      }
  }
  waitUntil(e) {
    return this._extendLifetimePromises.push(e), e;
  }
  async doneWaiting() {
    let e;
    for (; e = this._extendLifetimePromises.shift(); )
      await e;
  }
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  async _ensureResponseSafeToCache(e) {
    let t = e, a = !1;
    for (const n of this.iterateCallbacks("cacheWillUpdate"))
      if (t = await n({
        request: this.request,
        response: t,
        event: this.event
      }) || void 0, a = !0, !t)
        break;
    return a || (t && t.status !== 200 && (t = void 0), process.env.NODE_ENV !== "production" && t && t.status !== 200 && (t.status === 0 ? c.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`) : c.debug(`The response for '${this.request.url}' returned a status code of '${e.status}' and won't be cached as a result.`))), t;
  }
}
class he {
  constructor(e = {}) {
    this.cacheName = v.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions;
  }
  handle(e) {
    const [t] = this.handleAll(e);
    return t;
  }
  handleAll(e) {
    e instanceof FetchEvent && (e = {
      event: e,
      request: e.request
    });
    const t = e.event, a = typeof e.request == "string" ? new Request(e.request) : e.request, n = "params" in e ? e.params : void 0, r = new ue(this, { event: t, request: a, params: n }), o = this._getResponse(r, a, t), i = this._awaitComplete(o, r, a, t);
    return [o, i];
  }
  async _getResponse(e, t, a) {
    await e.runCallbacks("handlerWillStart", { event: a, request: t });
    let n;
    try {
      if (n = await this._handle(t, e), !n || n.type === "error")
        throw new u("no-response", { url: t.url });
    } catch (r) {
      if (r instanceof Error) {
        for (const o of e.iterateCallbacks("handlerDidError"))
          if (n = await o({ error: r, event: a, request: t }), n)
            break;
      }
      if (n)
        process.env.NODE_ENV !== "production" && c.log(`While responding to '${h(t.url)}', an ${r instanceof Error ? r.toString() : ""} error occurred. Using a fallback response provided by a handlerDidError plugin.`);
      else
        throw r;
    }
    for (const r of e.iterateCallbacks("handlerWillRespond"))
      n = await r({ event: a, request: t, response: n });
    return n;
  }
  async _awaitComplete(e, t, a, n) {
    let r, o;
    try {
      r = await e;
    } catch {
    }
    try {
      await t.runCallbacks("handlerDidRespond", {
        event: n,
        request: a,
        response: r
      }), await t.doneWaiting();
    } catch (i) {
      i instanceof Error && (o = i);
    }
    if (await t.runCallbacks("handlerDidComplete", {
      event: n,
      request: a,
      response: r,
      error: o
    }), t.destroy(), o)
      throw o;
  }
}
class w extends he {
  constructor(e = {}) {
    e.cacheName = v.getPrecacheName(e.cacheName), super(e), this._fallbackToNetwork = e.fallbackToNetwork !== !1, this.plugins.push(w.copyRedirectedCacheableResponsesPlugin);
  }
  async _handle(e, t) {
    const a = await t.cacheMatch(e);
    return a || (t.event && t.event.type === "install" ? await this._handleInstall(e, t) : await this._handleFetch(e, t));
  }
  async _handleFetch(e, t) {
    let a;
    const n = t.params || {};
    if (this._fallbackToNetwork) {
      process.env.NODE_ENV !== "production" && c.warn(`The precached response for ${h(e.url)} in ${this.cacheName} was not found. Falling back to the network.`);
      const r = n.integrity, o = e.integrity, i = !o || o === r;
      if (a = await t.fetch(new Request(e, {
        integrity: o || r
      })), r && i) {
        this._useDefaultCacheabilityPluginIfNeeded();
        const l = await t.cachePut(e, a.clone());
        process.env.NODE_ENV !== "production" && l && c.log(`A response for ${h(e.url)} was used to "repair" the precache.`);
      }
    } else
      throw new u("missing-precache-entry", {
        cacheName: this.cacheName,
        url: e.url
      });
    if (process.env.NODE_ENV !== "production") {
      const r = n.cacheKey || await t.getCacheKey(e, "read");
      c.groupCollapsed("Precaching is responding to: " + h(e.url)), c.log(`Serving the precached url: ${h(r instanceof Request ? r.url : r)}`), c.groupCollapsed("View request details here."), c.log(e), c.groupEnd(), c.groupCollapsed("View response details here."), c.log(a), c.groupEnd(), c.groupEnd();
    }
    return a;
  }
  async _handleInstall(e, t) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const a = await t.fetch(e);
    if (!await t.cachePut(e, a.clone()))
      throw new u("bad-precaching-response", {
        url: e.url,
        status: a.status
      });
    return a;
  }
  _useDefaultCacheabilityPluginIfNeeded() {
    let e = null, t = 0;
    for (const [a, n] of this.plugins.entries())
      n !== w.copyRedirectedCacheableResponsesPlugin && (n === w.defaultPrecacheCacheabilityPlugin && (e = a), n.cacheWillUpdate && t++);
    t === 0 ? this.plugins.push(w.defaultPrecacheCacheabilityPlugin) : t > 1 && e !== null && this.plugins.splice(e, 1);
  }
}
w.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response: s }) {
    return !s || s.status >= 400 ? null : s;
  }
};
w.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response: s }) {
    return s.redirected ? await re(s) : s;
  }
};
class pe {
  constructor({ cacheName: e, plugins: t = [], fallbackToNetwork: a = !0 } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map(), this._urlsToCacheModes = /* @__PURE__ */ new Map(), this._cacheKeysToIntegrities = /* @__PURE__ */ new Map(), this._strategy = new w({
      cacheName: v.getPrecacheName(e),
      plugins: [
        ...t,
        new ee({ precacheController: this })
      ],
      fallbackToNetwork: a
    }), this.install = this.install.bind(this), this.activate = this.activate.bind(this);
  }
  get strategy() {
    return this._strategy;
  }
  precache(e) {
    this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0);
  }
  addToCacheList(e) {
    process.env.NODE_ENV !== "production" && p.isArray(e, {
      moduleName: "workbox-precaching",
      className: "PrecacheController",
      funcName: "addToCacheList",
      paramName: "entries"
    });
    const t = [];
    for (const a of e) {
      typeof a == "string" ? t.push(a) : a && a.revision === void 0 && t.push(a.url);
      const { cacheKey: n, url: r } = Q(a), o = typeof a != "string" && a.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(r) && this._urlsToCacheKeys.get(r) !== n)
        throw new u("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(r),
          secondEntry: n
        });
      if (typeof a != "string" && a.integrity) {
        if (this._cacheKeysToIntegrities.has(n) && this._cacheKeysToIntegrities.get(n) !== a.integrity)
          throw new u("add-to-cache-list-conflicting-integrities", {
            url: r
          });
        this._cacheKeysToIntegrities.set(n, a.integrity);
      }
      if (this._urlsToCacheKeys.set(r, n), this._urlsToCacheModes.set(r, o), t.length > 0) {
        const i = `Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        process.env.NODE_ENV === "production" ? console.warn(i) : c.warn(i);
      }
    }
  }
  install(e) {
    return x(e, async () => {
      const t = new X();
      this.strategy.plugins.push(t);
      for (const [r, o] of this._urlsToCacheKeys) {
        const i = this._cacheKeysToIntegrities.get(o), l = this._urlsToCacheModes.get(r), g = new Request(r, {
          integrity: i,
          cache: l,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey: o },
          request: g,
          event: e
        }));
      }
      const { updatedURLs: a, notUpdatedURLs: n } = t;
      return process.env.NODE_ENV !== "production" && ae(a, n), { updatedURLs: a, notUpdatedURLs: n };
    });
  }
  activate(e) {
    return x(e, async () => {
      const t = await self.caches.open(this.strategy.cacheName), a = await t.keys(), n = new Set(this._urlsToCacheKeys.values()), r = [];
      for (const o of a)
        n.has(o.url) || (await t.delete(o), r.push(o.url));
      return process.env.NODE_ENV !== "production" && se(r), { deletedURLs: r };
    });
  }
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  getCacheKeyForURL(e) {
    const t = new URL(e, location.href);
    return this._urlsToCacheKeys.get(t.href);
  }
  getIntegrityForCacheKey(e) {
    return this._cacheKeysToIntegrities.get(e);
  }
  async matchPrecache(e) {
    const t = e instanceof Request ? e.url : e, a = this.getCacheKeyForURL(t);
    if (a)
      return (await self.caches.open(this.strategy.cacheName)).match(a);
  }
  createHandlerBoundToURL(e) {
    const t = this.getCacheKeyForURL(e);
    if (!t)
      throw new u("non-precached-url", { url: e });
    return (a) => (a.request = new Request(e), a.params = Object.assign({ cacheKey: t }, a.params), this.strategy.handle(a));
  }
}
let j;
const I = () => (j || (j = new pe()), j);
try {
  self["workbox:routing:6.5.2"] && _();
} catch {
}
const S = "GET", de = [
  "DELETE",
  "GET",
  "HEAD",
  "PATCH",
  "POST",
  "PUT"
], E = (s) => s && typeof s == "object" ? (process.env.NODE_ENV !== "production" && p.hasMethod(s, "handle", {
  moduleName: "workbox-routing",
  className: "Route",
  funcName: "constructor",
  paramName: "handler"
}), s) : (process.env.NODE_ENV !== "production" && p.isType(s, "function", {
  moduleName: "workbox-routing",
  className: "Route",
  funcName: "constructor",
  paramName: "handler"
}), { handle: s });
class N {
  constructor(e, t, a = S) {
    process.env.NODE_ENV !== "production" && (p.isType(e, "function", {
      moduleName: "workbox-routing",
      className: "Route",
      funcName: "constructor",
      paramName: "match"
    }), a && p.isOneOf(a, de, { paramName: "method" })), this.handler = E(t), this.match = e, this.method = a;
  }
  setCatchHandler(e) {
    this.catchHandler = E(e);
  }
}
class fe extends N {
  constructor(e, t, a) {
    process.env.NODE_ENV !== "production" && p.isInstance(e, RegExp, {
      moduleName: "workbox-routing",
      className: "RegExpRoute",
      funcName: "constructor",
      paramName: "pattern"
    });
    const n = ({ url: r }) => {
      const o = e.exec(r.href);
      if (!!o) {
        if (r.origin !== location.origin && o.index !== 0) {
          process.env.NODE_ENV !== "production" && c.debug(`The regular expression '${e.toString()}' only partially matched against the cross-origin URL '${r.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);
          return;
        }
        return o.slice(1);
      }
    };
    super(n, t, a);
  }
}
class me {
  constructor() {
    this._routes = /* @__PURE__ */ new Map(), this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  get routes() {
    return this._routes;
  }
  addFetchListener() {
    self.addEventListener("fetch", (e) => {
      const { request: t } = e, a = this.handleRequest({ request: t, event: e });
      a && e.respondWith(a);
    });
  }
  addCacheListener() {
    self.addEventListener("message", (e) => {
      if (e.data && e.data.type === "CACHE_URLS") {
        const { payload: t } = e.data;
        process.env.NODE_ENV !== "production" && c.debug("Caching URLs from the window", t.urlsToCache);
        const a = Promise.all(t.urlsToCache.map((n) => {
          typeof n == "string" && (n = [n]);
          const r = new Request(...n);
          return this.handleRequest({ request: r, event: e });
        }));
        e.waitUntil(a), e.ports && e.ports[0] && a.then(() => e.ports[0].postMessage(!0));
      }
    });
  }
  handleRequest({ request: e, event: t }) {
    process.env.NODE_ENV !== "production" && p.isInstance(e, Request, {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "handleRequest",
      paramName: "options.request"
    });
    const a = new URL(e.url, location.href);
    if (!a.protocol.startsWith("http")) {
      process.env.NODE_ENV !== "production" && c.debug("Workbox Router only supports URLs that start with 'http'.");
      return;
    }
    const n = a.origin === location.origin, { params: r, route: o } = this.findMatchingRoute({
      event: t,
      request: e,
      sameOrigin: n,
      url: a
    });
    let i = o && o.handler;
    const l = [];
    process.env.NODE_ENV !== "production" && i && (l.push(["Found a route to handle this request:", o]), r && l.push([
      "Passing the following params to the route's handler:",
      r
    ]));
    const g = e.method;
    if (!i && this._defaultHandlerMap.has(g) && (process.env.NODE_ENV !== "production" && l.push(`Failed to find a matching route. Falling back to the default handler for ${g}.`), i = this._defaultHandlerMap.get(g)), !i) {
      process.env.NODE_ENV !== "production" && c.debug(`No route found for: ${h(a)}`);
      return;
    }
    process.env.NODE_ENV !== "production" && (c.groupCollapsed(`Router is responding to: ${h(a)}`), l.forEach((f) => {
      Array.isArray(f) ? c.log(...f) : c.log(f);
    }), c.groupEnd());
    let b;
    try {
      b = i.handle({ url: a, request: e, event: t, params: r });
    } catch (f) {
      b = Promise.reject(f);
    }
    const d = o && o.catchHandler;
    return b instanceof Promise && (this._catchHandler || d) && (b = b.catch(async (f) => {
      if (d) {
        process.env.NODE_ENV !== "production" && (c.groupCollapsed(`Error thrown when responding to:  ${h(a)}. Falling back to route's Catch Handler.`), c.error("Error thrown by:", o), c.error(f), c.groupEnd());
        try {
          return await d.handle({ url: a, request: e, event: t, params: r });
        } catch ($) {
          $ instanceof Error && (f = $);
        }
      }
      if (this._catchHandler)
        return process.env.NODE_ENV !== "production" && (c.groupCollapsed(`Error thrown when responding to:  ${h(a)}. Falling back to global Catch Handler.`), c.error("Error thrown by:", o), c.error(f), c.groupEnd()), this._catchHandler.handle({ url: a, request: e, event: t });
      throw f;
    })), b;
  }
  findMatchingRoute({ url: e, sameOrigin: t, request: a, event: n }) {
    const r = this._routes.get(a.method) || [];
    for (const o of r) {
      let i;
      const l = o.match({ url: e, sameOrigin: t, request: a, event: n });
      if (l)
        return process.env.NODE_ENV !== "production" && l instanceof Promise && c.warn(`While routing ${h(e)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, o), i = l, (Array.isArray(i) && i.length === 0 || l.constructor === Object && Object.keys(l).length === 0 || typeof l == "boolean") && (i = void 0), { route: o, params: i };
    }
    return {};
  }
  setDefaultHandler(e, t = S) {
    this._defaultHandlerMap.set(t, E(e));
  }
  setCatchHandler(e) {
    this._catchHandler = E(e);
  }
  registerRoute(e) {
    process.env.NODE_ENV !== "production" && (p.isType(e, "object", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), p.hasMethod(e, "match", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), p.isType(e.handler, "object", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), p.hasMethod(e.handler, "handle", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route.handler"
    }), p.isType(e.method, "string", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route.method"
    })), this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e);
  }
  unregisterRoute(e) {
    if (!this._routes.has(e.method))
      throw new u("unregister-route-but-not-found-with-method", {
        method: e.method
      });
    const t = this._routes.get(e.method).indexOf(e);
    if (t > -1)
      this._routes.get(e.method).splice(t, 1);
    else
      throw new u("unregister-route-route-not-registered");
  }
}
let k;
const ge = () => (k || (k = new me(), k.addFetchListener(), k.addCacheListener()), k);
function be(s, e, t) {
  let a;
  if (typeof s == "string") {
    const r = new URL(s, location.href);
    if (process.env.NODE_ENV !== "production") {
      if (!(s.startsWith("/") || s.startsWith("http")))
        throw new u("invalid-string", {
          moduleName: "workbox-routing",
          funcName: "registerRoute",
          paramName: "capture"
        });
      const i = s.startsWith("http") ? r.pathname : s, l = "[*:?+]";
      new RegExp(`${l}`).exec(i) && c.debug(`The '$capture' parameter contains an Express-style wildcard character (${l}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);
    }
    const o = ({ url: i }) => (process.env.NODE_ENV !== "production" && i.pathname === r.pathname && i.origin !== r.origin && c.debug(`${s} only partially matches the cross-origin URL ${i.toString()}. This route will only handle cross-origin requests if they match the entire URL.`), i.href === r.href);
    a = new N(o, e, t);
  } else if (s instanceof RegExp)
    a = new fe(s, e, t);
  else if (typeof s == "function")
    a = new N(s, e, t);
  else if (s instanceof N)
    a = s;
  else
    throw new u("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  return ge().registerRoute(a), a;
}
function we(s, e = []) {
  for (const t of [...s.searchParams.keys()])
    e.some((a) => a.test(t)) && s.searchParams.delete(t);
  return s;
}
function* ye(s, { ignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/], directoryIndex: t = "index.html", cleanURLs: a = !0, urlManipulation: n } = {}) {
  const r = new URL(s, location.href);
  r.hash = "", yield r.href;
  const o = we(r, e);
  if (yield o.href, t && o.pathname.endsWith("/")) {
    const i = new URL(o.href);
    i.pathname += t, yield i.href;
  }
  if (a) {
    const i = new URL(o.href);
    i.pathname += ".html", yield i.href;
  }
  if (n) {
    const i = n({ url: r });
    for (const l of i)
      yield l.href;
  }
}
class ke extends N {
  constructor(e, t) {
    const a = ({ request: n }) => {
      const r = e.getURLsToCacheKeys();
      for (const o of ye(n.url, t)) {
        const i = r.get(o);
        if (i) {
          const l = e.getIntegrityForCacheKey(i);
          return { cacheKey: i, integrity: l };
        }
      }
      process.env.NODE_ENV !== "production" && c.debug("Precaching did not find a match for " + h(n.url));
    };
    super(a, e.strategy);
  }
}
function Ne(s) {
  const e = I(), t = new ke(e, s);
  be(t);
}
const Re = "-precache-", Ee = async (s, e = Re) => {
  const a = (await self.caches.keys()).filter((n) => n.includes(e) && n.includes(self.registration.scope) && n !== s);
  return await Promise.all(a.map((n) => self.caches.delete(n))), a;
};
function ve() {
  self.addEventListener("activate", (s) => {
    const e = v.getPrecacheName();
    s.waitUntil(Ee(e).then((t) => {
      process.env.NODE_ENV !== "production" && t.length > 0 && c.log("The following out-of-date precaches were cleaned up automatically:", t);
    }));
  });
}
function _e(s) {
  I().precache(s);
}
function Ce(s, e) {
  _e(s), Ne(e);
}
console.log("Hello from service-worker.js", { build: O, files: L, prerendered: P, version: V });
const K = [...L, ...P, ...O].filter((s) => !s.endsWith(".jpeg") && !s.endsWith(".png") && !s.endsWith(".pdf")).filter((s) => !s.startsWith("/."));
console.log("Service worker urls: ", K);
Ce(
  K.map((s) => ({
    url: s,
    revision: V
  })),
  {
    cleanURLs: !1
  }
);
ve();
self.addEventListener("install", () => {
  self.skipWaiting();
});
