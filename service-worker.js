const U = [
  "/internal/immutable/assets/fira-mono-cyrillic-ext-400-normal-3df7909e.woff2",
  "/internal/immutable/assets/fira-mono-cyrillic-400-normal-c7d433fd.woff2",
  "/internal/immutable/assets/fira-mono-greek-ext-400-normal-9e2fe623.woff2",
  "/internal/immutable/assets/fira-mono-greek-400-normal-a8be01ce.woff2",
  "/internal/immutable/assets/fira-mono-latin-ext-400-normal-6bfabd30.woff2",
  "/internal/immutable/assets/fira-mono-latin-400-normal-e43b3538.woff2",
  "/internal/immutable/assets/fira-mono-all-400-normal-1e3b098c.woff",
  "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2019-bdc8a1d7.js",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2019-93acf6d0.jpeg",
  "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2020-c9371c25.js",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2020-2b678c79.jpeg",
  "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2021-165e0297.js",
  "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2021-de46e89f.jpeg",
  "/internal/immutable/chunks/Dusza-2019-dee31e1f.js",
  "/internal/immutable/assets/Dusza-2019-35684b17.jpeg",
  "/internal/immutable/chunks/Dusza-2020-c1c72382.js",
  "/internal/immutable/assets/Dusza-2020-45830cb7.jpeg",
  "/internal/immutable/chunks/Dusza-mobil-2020-5c3351cf.js",
  "/internal/immutable/assets/Dusza-mobil-2020-fd3b6a24.jpeg",
  "/internal/immutable/chunks/Dusza-mobil-2021-1f84f249.js",
  "/internal/immutable/assets/Dusza-mobil-2021-9a8ceeb4.jpeg",
  "/internal/immutable/chunks/Ifju-Tudosok-2022-55ad7a81.js",
  "/internal/immutable/assets/Ifju-Tudosok-2022-66758e93.jpeg",
  "/internal/immutable/chunks/Dusza-mobil-2019-3e4d948d.js",
  "/internal/immutable/assets/Dusza-mobil-2019-721cb137.jpeg",
  "/internal/immutable/chunks/Innovacios-tehetsegkutato-2020-750c0d90.js",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2020-57e8b332.jpeg",
  "/internal/immutable/chunks/Innovacios-tehetsegkutato-2021-d78bce4b.js",
  "/internal/immutable/assets/Innovacios-tehetsegkutato-2021-e24552e1.jpeg",
  "/internal/immutable/chunks/Iskola-programozas-verseny-2018-bc488745.js",
  "/internal/immutable/assets/Iskola-programozas-verseny-2018-3f5ff933.jpeg",
  "/internal/immutable/chunks/Kodolj-Hatarok-Nelkul-2020-cfd79b50.js",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2020-bbd8c8ca.jpeg",
  "/internal/immutable/chunks/Kodolj-Hatarok-Nelkul-2021-881ff0de.js",
  "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2021-2a73ea96.jpeg",
  "/internal/immutable/chunks/ASZEV2022-7880cdac.js",
  "/internal/immutable/assets/ASZEV2022-89e1cc38.jpeg",
  "/internal/immutable/chunks/Merklik-2021-26e48fac.js",
  "/internal/immutable/assets/Merklik-2021-c483c600.jpeg",
  "/internal/immutable/chunks/Nemes-Tihamer-2019-47dc9912.js",
  "/internal/immutable/assets/Nemes-Tihamer-2019-259bb313.jpeg",
  "/internal/immutable/chunks/SZIIV-2019-63ec36f4.js",
  "/internal/immutable/assets/SZIIV-2019-c3c1339f.jpeg",
  "/internal/immutable/chunks/SZIIV-2020-5026d4df.js",
  "/internal/immutable/assets/SZIIV-2020-8240b8b4.jpeg",
  "/internal/immutable/chunks/Skills-Junior-Web-2022-a743f0d7.js",
  "/internal/immutable/assets/Skills-Junior-Web-2022-4fbac8e3.jpeg",
  "/internal/immutable/chunks/Webex-Teams-Hackathlon-2019-photo-78c3c23d.js",
  "/internal/immutable/assets/Webex-Teams-Hackathlon-2019-photo-d924e58a.jpeg",
  "/internal/immutable/assets/_layout-138e1b49.css",
  "/internal/immutable/assets/service-60614438.css",
  "/internal/immutable/assets/MeCard-7b1e9f2c.css",
  "/internal/immutable/assets/_page-defec1af.css",
  "/internal/immutable/assets/_page-e0148492.css",
  "/internal/immutable/assets/_page-4ff9918c.css",
  "/internal/immutable/assets/_page-50378ec7.css",
  "/internal/immutable/assets/_page-42a5e5d1.css",
  "/internal/immutable/assets/Face-52089387.css",
  "/internal/immutable/assets/_post-e754f88c.css",
  "/internal/immutable/assets/app-e31199ff.css",
  "/internal/immutable/assets/github-markdown-42b94d5a.css",
  "/internal/immutable/chunks/_post-f034e130.js",
  "/internal/immutable/chunks/Face-d3e9ebc7.js",
  "/internal/immutable/chunks/hidden-post-c244dd8e.js",
  "/internal/immutable/chunks/getLongestTextElement-29cbbbbc.js",
  "/internal/immutable/chunks/welcome-e1379ad6.js",
  "/internal/immutable/modules/pages/_layout.ts-b411215a.js",
  "/internal/immutable/chunks/emojik-es-a-windows-09de7235.js",
  "/internal/immutable/chunks/giscus.es-01a213ab.js",
  "/internal/immutable/modules/pages/(web)/_page.ts-94291217.js",
  "/internal/immutable/modules/pages/(web)/posts/_page.ts-3dd1ad5c.js",
  "/internal/immutable/modules/pages/(web)/posts/_post_/_page.ts-b78b1c97.js",
  "/internal/immutable/components/pages/(web)/404/_page.svelte-73fcdc0e.js",
  "/internal/immutable/chunks/stores-b5c5c1c0.js",
  "/internal/immutable/chunks/app-2d8d75ee.js",
  "/internal/immutable/components/pages/(min)/_layout.svelte-adff6c25.js",
  "/internal/immutable/chunks/index-1abd32fd.js",
  "/internal/immutable/chunks/control-f5b05b5f.js",
  "/internal/immutable/chunks/preload-helper-41c905a7.js",
  "/internal/immutable/start-c642b05c.js",
  "/internal/immutable/components/pages/_layout.svelte-37b32647.js",
  "/internal/immutable/chunks/mail-b948d46f.js",
  "/internal/immutable/chunks/runOnEveryParentUntil-67f0ce31.js",
  "/internal/immutable/components/pages/(none)/me-card-wrapped/_page.svelte-4b958b14.js",
  "/internal/immutable/chunks/_page-da46b06b.js",
  "/internal/immutable/chunks/_page-41711a71.js",
  "/internal/immutable/components/pages/(web)/posts/_post_/_page.svelte-2beff5cc.js",
  "/internal/immutable/chunks/0-8e0a7449.js",
  "/internal/immutable/chunks/_page-cb905ec4.js",
  "/internal/immutable/chunks/1-3b350bfd.js",
  "/internal/immutable/chunks/2-95a73794.js",
  "/internal/immutable/chunks/3-140201da.js",
  "/internal/immutable/chunks/4-b3329242.js",
  "/internal/immutable/chunks/5-48e37ab9.js",
  "/internal/immutable/chunks/7-12c642a8.js",
  "/internal/immutable/chunks/6-c293fcdf.js",
  "/internal/immutable/chunks/8-1bb35758.js",
  "/internal/immutable/chunks/9-852aa1c1.js",
  "/internal/immutable/chunks/10-9e4904a0.js",
  "/internal/immutable/chunks/index-537aee01.js",
  "/internal/immutable/chunks/writeEffect-748b5f3a.js",
  "/internal/immutable/chunks/scramble-48e08db1.js",
  "/internal/immutable/chunks/typewriter-1e983e07.js",
  "/internal/immutable/chunks/sleep-ea0e718f.js",
  "/internal/immutable/components/pages/(min)/me/_page.svelte-31c84c6a.js",
  "/internal/immutable/components/pages/(web)/_layout.svelte-a548642e.js",
  "/internal/immutable/components/error.svelte-032ee067.js",
  "/internal/immutable/chunks/loopTypewriter-80568ecd.js",
  "/internal/immutable/chunks/pathseg-234b9b0b.js",
  "/internal/immutable/chunks/_layout-34122678.js",
  "/internal/immutable/chunks/index-2ac3dbf5.js",
  "/internal/immutable/components/pages/(web)/_page.svelte-68731617.js",
  "/internal/immutable/chunks/singletons-b3bcd9ea.js",
  "/internal/immutable/components/pages/(web)/posts/_page.svelte-2d69cb31.js",
  "/internal/immutable/components/pages/(none)/readme/_page.svelte-ea3ef774.js",
  "/internal/immutable/chunks/Icon-111ef362.js",
  "/internal/immutable/chunks/service-3f13ad91.js",
  "/internal/immutable/chunks/index-14421b90.js",
  "/internal/immutable/chunks/MeCard-55d976f7.js"
], x = [
  "/.nojekyll",
  "/android-chrome-192x192.png",
  "/android-chrome-512x512.png",
  "/apple-touch-icon.png",
  "/assets/card/windmill.svg",
  "/assets/certificates/CCNA-1-certificate.pdf",
  "/assets/certificates/CCNA-2-certificate.pdf",
  "/assets/competitions/ASZEV2022.jpeg",
  "/assets/competitions/Accenture Java 2020.pdf",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.jpeg",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.jpeg",
  "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.jpeg",
  "/assets/competitions/Dusza-2019.jpeg",
  "/assets/competitions/Dusza-2020.jpeg",
  "/assets/competitions/Dusza-mobil-2019.jpeg",
  "/assets/competitions/Dusza-mobil-2020.jpeg",
  "/assets/competitions/Dusza-mobil-2021.jpeg",
  "/assets/competitions/GAMF programozÃ³ verseny 2020.pdf",
  "/assets/competitions/Ifju-Tudosok-2022.jpeg",
  "/assets/competitions/Innovacios-tehetsegkutato-2020.jpeg",
  "/assets/competitions/Innovacios-tehetsegkutato-2021.jpeg",
  "/assets/competitions/Iskola-programozas-verseny-2018.jpeg",
  "/assets/competitions/Kodolj-Hatarok-Nelkul-2020.jpeg",
  "/assets/competitions/Kodolj-Hatarok-Nelkul-2021.jpeg",
  "/assets/competitions/Merklik-2021.jpeg",
  "/assets/competitions/Nemes-Tihamer-2019.jpeg",
  "/assets/competitions/Nemes-Tihamer-2020.pdf",
  "/assets/competitions/SZIIV-2019.jpeg",
  "/assets/competitions/SZIIV-2020.jpeg",
  "/assets/competitions/Skills-Junior-Web-2022.jpeg",
  "/assets/competitions/Webex-Teams-Hackathlon-2019-photo.jpeg",
  "/assets/og-banner.jpg",
  "/assets/people/sk.jpeg",
  "/assets/people/unknownhe.jpeg",
  "/assets/posts/yt1f9UbfqqHlknfx-image-1653148385384.png",
  "/favicon-16x16.png",
  "/favicon-32x32.png",
  "/favicon.ico",
  "/manifest.json",
  "/readme-template.md",
  "/robots.txt"
], L = [
  "/",
  "/shlinks/---.txt",
  "/404",
  "/shlinks/---404.txt",
  "/business-card-back.svg",
  "/business-card-front.svg",
  "/me-card-wrapped",
  "/shlinks/---me-card-wrapped.txt",
  "/me",
  "/shlinks/---me.txt",
  "/posts",
  "/shlinks/---posts.txt",
  "/readme.md",
  "/readme",
  "/shlinks/---readme.txt",
  "/readme/__data.json",
  "/rss.xml",
  "/sitemap.xml",
  "/posts/emojik-es-a-windows",
  "/shlinks/---posts---emojik-es-a-windows.txt",
  "/posts/hidden-post",
  "/shlinks/---posts---hidden-post.txt",
  "/posts/welcome",
  "/shlinks/---posts---welcome.txt",
  "/images/competitions/ASZEV2022.jpg",
  "/images/competitions/ASZEV2022.webp",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.jpg",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.webp",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.jpg",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.webp",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.jpg",
  "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.webp",
  "/images/competitions/Dusza-2019.jpg",
  "/images/competitions/Dusza-2019.webp",
  "/images/competitions/Dusza-2020.jpg",
  "/images/competitions/Dusza-2020.webp",
  "/images/competitions/Dusza-mobil-2019.jpg",
  "/images/competitions/Dusza-mobil-2019.webp",
  "/images/competitions/Dusza-mobil-2020.jpg",
  "/images/competitions/Dusza-mobil-2020.webp",
  "/images/competitions/Dusza-mobil-2021.jpg",
  "/images/competitions/Dusza-mobil-2021.webp",
  "/images/competitions/Ifju-Tudosok-2022.jpg",
  "/images/competitions/Ifju-Tudosok-2022.webp",
  "/images/competitions/Innovacios-tehetsegkutato-2020.jpg",
  "/images/competitions/Innovacios-tehetsegkutato-2020.webp",
  "/images/competitions/Innovacios-tehetsegkutato-2021.jpg",
  "/images/competitions/Innovacios-tehetsegkutato-2021.webp",
  "/images/competitions/Iskola-programozas-verseny-2018.jpg",
  "/images/competitions/Iskola-programozas-verseny-2018.webp",
  "/images/competitions/Kodolj-Hatarok-Nelkul-2020.jpg",
  "/images/competitions/Kodolj-Hatarok-Nelkul-2020.webp",
  "/images/competitions/Kodolj-Hatarok-Nelkul-2021.jpg",
  "/images/competitions/Kodolj-Hatarok-Nelkul-2021.webp",
  "/images/competitions/Merklik-2021.jpg",
  "/images/competitions/Merklik-2021.webp",
  "/images/competitions/Nemes-Tihamer-2019.jpg",
  "/images/competitions/Nemes-Tihamer-2019.webp",
  "/images/competitions/SZIIV-2019.jpg",
  "/images/competitions/SZIIV-2019.webp",
  "/images/competitions/SZIIV-2020.jpg",
  "/images/competitions/SZIIV-2020.webp",
  "/images/competitions/Skills-Junior-Web-2022.jpg",
  "/images/competitions/Skills-Junior-Web-2022.webp",
  "/images/competitions/Webex-Teams-Hackathlon-2019-photo.jpg",
  "/images/competitions/Webex-Teams-Hackathlon-2019-photo.webp"
], T = "1672134369266";
try {
  self["workbox:core:6.5.3"] && _();
} catch {
}
const B = (a, ...e) => {
  let t = a;
  return e.length > 0 && (t += ` :: ${JSON.stringify(e)}`), t;
}, D = B;
class l extends Error {
  constructor(e, t) {
    const s = D(e, t);
    super(s), this.name = e, this.details = t;
  }
}
const m = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration < "u" ? registration.scope : ""
}, j = (a) => [m.prefix, a, m.suffix].filter((e) => e && e.length > 0).join("-"), S = (a) => {
  for (const e of Object.keys(m))
    a(e);
}, y = {
  updateDetails: (a) => {
    S((e) => {
      typeof a[e] == "string" && (m[e] = a[e]);
    });
  },
  getGoogleAnalyticsName: (a) => a || j(m.googleAnalytics),
  getPrecacheName: (a) => a || j(m.precache),
  getPrefix: () => m.prefix,
  getRuntimeName: (a) => a || j(m.runtime),
  getSuffix: () => m.suffix
};
function v(a, e) {
  const t = e();
  return a.waitUntil(t), t;
}
try {
  self["workbox:precaching:6.5.3"] && _();
} catch {
}
const E = "__WB_REVISION__";
function W(a) {
  if (!a)
    throw new l("add-to-cache-list-unexpected-type", { entry: a });
  if (typeof a == "string") {
    const i = new URL(a, location.href);
    return {
      cacheKey: i.href,
      url: i.href
    };
  }
  const { revision: e, url: t } = a;
  if (!t)
    throw new l("add-to-cache-list-unexpected-type", { entry: a });
  if (!e) {
    const i = new URL(t, location.href);
    return {
      cacheKey: i.href,
      url: i.href
    };
  }
  const s = new URL(t, location.href), n = new URL(t, location.href);
  return s.searchParams.set(E, e), {
    cacheKey: s.href,
    url: n.href
  };
}
class H {
  constructor() {
    this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: t }) => {
      t && (t.originalRequest = e);
    }, this.cachedResponseWillBeUsed = async ({ event: e, state: t, cachedResponse: s }) => {
      if (e.type === "install" && t && t.originalRequest && t.originalRequest instanceof Request) {
        const n = t.originalRequest.url;
        s ? this.notUpdatedURLs.push(n) : this.updatedURLs.push(n);
      }
      return s;
    };
  }
}
class M {
  constructor({ precacheController: e }) {
    this.cacheKeyWillBeUsed = async ({ request: t, params: s }) => {
      const n = (s == null ? void 0 : s.cacheKey) || this._precacheController.getCacheKeyForURL(t.url);
      return n ? new Request(n, { headers: t.headers }) : t;
    }, this._precacheController = e;
  }
}
let d;
function O() {
  if (d === void 0) {
    const a = new Response("");
    if ("body" in a)
      try {
        new Response(a.body), d = !0;
      } catch {
        d = !1;
      }
    d = !1;
  }
  return d;
}
async function z(a, e) {
  let t = null;
  if (a.url && (t = new URL(a.url).origin), t !== self.location.origin)
    throw new l("cross-origin-copy-response", { origin: t });
  const s = a.clone(), n = {
    headers: new Headers(s.headers),
    status: s.status,
    statusText: s.statusText
  }, i = e ? e(n) : n, o = O() ? s.body : await s.blob();
  return new Response(o, i);
}
const A = (a) => new URL(String(a), location.href).href.replace(new RegExp(`^${location.origin}`), "");
function I(a, e) {
  const t = new URL(a);
  for (const s of e)
    t.searchParams.delete(s);
  return t.href;
}
async function q(a, e, t, s) {
  const n = I(e.url, t);
  if (e.url === n)
    return a.match(e, s);
  const i = Object.assign(Object.assign({}, s), { ignoreSearch: !0 }), o = await a.keys(e, i);
  for (const c of o) {
    const r = I(c.url, t);
    if (n === r)
      return a.match(c, s);
  }
}
class F {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
const V = /* @__PURE__ */ new Set();
async function Z() {
  for (const a of V)
    await a();
}
function J(a) {
  return new Promise((e) => setTimeout(e, a));
}
try {
  self["workbox:strategies:6.5.3"] && _();
} catch {
}
function k(a) {
  return typeof a == "string" ? new Request(a) : a;
}
class $ {
  constructor(e, t) {
    this._cacheKeys = {}, Object.assign(this, t), this.event = t.event, this._strategy = e, this._handlerDeferred = new F(), this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const s of this._plugins)
      this._pluginStateMap.set(s, {});
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  async fetch(e) {
    const { event: t } = this;
    let s = k(e);
    if (s.mode === "navigate" && t instanceof FetchEvent && t.preloadResponse) {
      const o = await t.preloadResponse;
      if (o)
        return o;
    }
    const n = this.hasCallback("fetchDidFail") ? s.clone() : null;
    try {
      for (const o of this.iterateCallbacks("requestWillFetch"))
        s = await o({ request: s.clone(), event: t });
    } catch (o) {
      if (o instanceof Error)
        throw new l("plugin-error-request-will-fetch", {
          thrownErrorMessage: o.message
        });
    }
    const i = s.clone();
    try {
      let o;
      o = await fetch(s, s.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
      for (const c of this.iterateCallbacks("fetchDidSucceed"))
        o = await c({
          event: t,
          request: i,
          response: o
        });
      return o;
    } catch (o) {
      throw n && await this.runCallbacks("fetchDidFail", {
        error: o,
        event: t,
        originalRequest: n.clone(),
        request: i.clone()
      }), o;
    }
  }
  async fetchAndCachePut(e) {
    const t = await this.fetch(e), s = t.clone();
    return this.waitUntil(this.cachePut(e, s)), t;
  }
  async cacheMatch(e) {
    const t = k(e);
    let s;
    const { cacheName: n, matchOptions: i } = this._strategy, o = await this.getCacheKey(t, "read"), c = Object.assign(Object.assign({}, i), { cacheName: n });
    s = await caches.match(o, c);
    for (const r of this.iterateCallbacks("cachedResponseWillBeUsed"))
      s = await r({
        cacheName: n,
        matchOptions: i,
        cachedResponse: s,
        request: o,
        event: this.event
      }) || void 0;
    return s;
  }
  async cachePut(e, t) {
    const s = k(e);
    await J(0);
    const n = await this.getCacheKey(s, "write");
    if (!t)
      throw new l("cache-put-with-no-response", {
        url: A(n.url)
      });
    const i = await this._ensureResponseSafeToCache(t);
    if (!i)
      return !1;
    const { cacheName: o, matchOptions: c } = this._strategy, r = await self.caches.open(o), u = this.hasCallback("cacheDidUpdate"), f = u ? await q(
      r,
      n.clone(),
      ["__WB_REVISION__"],
      c
    ) : null;
    try {
      await r.put(n, u ? i.clone() : i);
    } catch (h) {
      if (h instanceof Error)
        throw h.name === "QuotaExceededError" && await Z(), h;
    }
    for (const h of this.iterateCallbacks("cacheDidUpdate"))
      await h({
        cacheName: o,
        oldResponse: f,
        newResponse: i.clone(),
        request: n,
        event: this.event
      });
    return !0;
  }
  async getCacheKey(e, t) {
    const s = `${e.url} | ${t}`;
    if (!this._cacheKeys[s]) {
      let n = e;
      for (const i of this.iterateCallbacks("cacheKeyWillBeUsed"))
        n = k(await i({
          mode: t,
          request: n,
          event: this.event,
          params: this.params
        }));
      this._cacheKeys[s] = n;
    }
    return this._cacheKeys[s];
  }
  hasCallback(e) {
    for (const t of this._strategy.plugins)
      if (e in t)
        return !0;
    return !1;
  }
  async runCallbacks(e, t) {
    for (const s of this.iterateCallbacks(e))
      await s(t);
  }
  *iterateCallbacks(e) {
    for (const t of this._strategy.plugins)
      if (typeof t[e] == "function") {
        const s = this._pluginStateMap.get(t);
        yield (i) => {
          const o = Object.assign(Object.assign({}, i), { state: s });
          return t[e](o);
        };
      }
  }
  waitUntil(e) {
    return this._extendLifetimePromises.push(e), e;
  }
  async doneWaiting() {
    let e;
    for (; e = this._extendLifetimePromises.shift(); )
      await e;
  }
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  async _ensureResponseSafeToCache(e) {
    let t = e, s = !1;
    for (const n of this.iterateCallbacks("cacheWillUpdate"))
      if (t = await n({
        request: this.request,
        response: t,
        event: this.event
      }) || void 0, s = !0, !t)
        break;
    return s || t && t.status !== 200 && (t = void 0), t;
  }
}
class G {
  constructor(e = {}) {
    this.cacheName = y.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions;
  }
  handle(e) {
    const [t] = this.handleAll(e);
    return t;
  }
  handleAll(e) {
    e instanceof FetchEvent && (e = {
      event: e,
      request: e.request
    });
    const t = e.event, s = typeof e.request == "string" ? new Request(e.request) : e.request, n = "params" in e ? e.params : void 0, i = new $(this, { event: t, request: s, params: n }), o = this._getResponse(i, s, t), c = this._awaitComplete(o, i, s, t);
    return [o, c];
  }
  async _getResponse(e, t, s) {
    await e.runCallbacks("handlerWillStart", { event: s, request: t });
    let n;
    try {
      if (n = await this._handle(t, e), !n || n.type === "error")
        throw new l("no-response", { url: t.url });
    } catch (i) {
      if (i instanceof Error) {
        for (const o of e.iterateCallbacks("handlerDidError"))
          if (n = await o({ error: i, event: s, request: t }), n)
            break;
      }
      if (!n)
        throw i;
    }
    for (const i of e.iterateCallbacks("handlerWillRespond"))
      n = await i({ event: s, request: t, response: n });
    return n;
  }
  async _awaitComplete(e, t, s, n) {
    let i, o;
    try {
      i = await e;
    } catch {
    }
    try {
      await t.runCallbacks("handlerDidRespond", {
        event: n,
        request: s,
        response: i
      }), await t.doneWaiting();
    } catch (c) {
      c instanceof Error && (o = c);
    }
    if (await t.runCallbacks("handlerDidComplete", {
      event: n,
      request: s,
      response: i,
      error: o
    }), t.destroy(), o)
      throw o;
  }
}
class p extends G {
  constructor(e = {}) {
    e.cacheName = y.getPrecacheName(e.cacheName), super(e), this._fallbackToNetwork = e.fallbackToNetwork !== !1, this.plugins.push(p.copyRedirectedCacheableResponsesPlugin);
  }
  async _handle(e, t) {
    const s = await t.cacheMatch(e);
    return s || (t.event && t.event.type === "install" ? await this._handleInstall(e, t) : await this._handleFetch(e, t));
  }
  async _handleFetch(e, t) {
    let s;
    const n = t.params || {};
    if (this._fallbackToNetwork) {
      const i = n.integrity, o = e.integrity, c = !o || o === i;
      s = await t.fetch(new Request(e, {
        integrity: e.mode !== "no-cors" ? o || i : void 0
      })), i && c && e.mode !== "no-cors" && (this._useDefaultCacheabilityPluginIfNeeded(), await t.cachePut(e, s.clone()));
    } else
      throw new l("missing-precache-entry", {
        cacheName: this.cacheName,
        url: e.url
      });
    return s;
  }
  async _handleInstall(e, t) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const s = await t.fetch(e);
    if (!await t.cachePut(e, s.clone()))
      throw new l("bad-precaching-response", {
        url: e.url,
        status: s.status
      });
    return s;
  }
  _useDefaultCacheabilityPluginIfNeeded() {
    let e = null, t = 0;
    for (const [s, n] of this.plugins.entries())
      n !== p.copyRedirectedCacheableResponsesPlugin && (n === p.defaultPrecacheCacheabilityPlugin && (e = s), n.cacheWillUpdate && t++);
    t === 0 ? this.plugins.push(p.defaultPrecacheCacheabilityPlugin) : t > 1 && e !== null && this.plugins.splice(e, 1);
  }
}
p.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response: a }) {
    return !a || a.status >= 400 ? null : a;
  }
};
p.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response: a }) {
    return a.redirected ? await z(a) : a;
  }
};
class Q {
  constructor({ cacheName: e, plugins: t = [], fallbackToNetwork: s = !0 } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map(), this._urlsToCacheModes = /* @__PURE__ */ new Map(), this._cacheKeysToIntegrities = /* @__PURE__ */ new Map(), this._strategy = new p({
      cacheName: y.getPrecacheName(e),
      plugins: [
        ...t,
        new M({ precacheController: this })
      ],
      fallbackToNetwork: s
    }), this.install = this.install.bind(this), this.activate = this.activate.bind(this);
  }
  get strategy() {
    return this._strategy;
  }
  precache(e) {
    this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0);
  }
  addToCacheList(e) {
    const t = [];
    for (const s of e) {
      typeof s == "string" ? t.push(s) : s && s.revision === void 0 && t.push(s.url);
      const { cacheKey: n, url: i } = W(s), o = typeof s != "string" && s.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(i) && this._urlsToCacheKeys.get(i) !== n)
        throw new l("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(i),
          secondEntry: n
        });
      if (typeof s != "string" && s.integrity) {
        if (this._cacheKeysToIntegrities.has(n) && this._cacheKeysToIntegrities.get(n) !== s.integrity)
          throw new l("add-to-cache-list-conflicting-integrities", {
            url: i
          });
        this._cacheKeysToIntegrities.set(n, s.integrity);
      }
      if (this._urlsToCacheKeys.set(i, n), this._urlsToCacheModes.set(i, o), t.length > 0) {
        const c = `Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        console.warn(c);
      }
    }
  }
  install(e) {
    return v(e, async () => {
      const t = new H();
      this.strategy.plugins.push(t);
      for (const [i, o] of this._urlsToCacheKeys) {
        const c = this._cacheKeysToIntegrities.get(o), r = this._urlsToCacheModes.get(i), u = new Request(i, {
          integrity: c,
          cache: r,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey: o },
          request: u,
          event: e
        }));
      }
      const { updatedURLs: s, notUpdatedURLs: n } = t;
      return { updatedURLs: s, notUpdatedURLs: n };
    });
  }
  activate(e) {
    return v(e, async () => {
      const t = await self.caches.open(this.strategy.cacheName), s = await t.keys(), n = new Set(this._urlsToCacheKeys.values()), i = [];
      for (const o of s)
        n.has(o.url) || (await t.delete(o), i.push(o.url));
      return { deletedURLs: i };
    });
  }
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  getCacheKeyForURL(e) {
    const t = new URL(e, location.href);
    return this._urlsToCacheKeys.get(t.href);
  }
  getIntegrityForCacheKey(e) {
    return this._cacheKeysToIntegrities.get(e);
  }
  async matchPrecache(e) {
    const t = e instanceof Request ? e.url : e, s = this.getCacheKeyForURL(t);
    if (s)
      return (await self.caches.open(this.strategy.cacheName)).match(s);
  }
  createHandlerBoundToURL(e) {
    const t = this.getCacheKeyForURL(e);
    if (!t)
      throw new l("non-precached-url", { url: e });
    return (s) => (s.request = new Request(e), s.params = Object.assign({ cacheKey: t }, s.params), this.strategy.handle(s));
  }
}
let R;
const K = () => (R || (R = new Q()), R);
try {
  self["workbox:routing:6.5.3"] && _();
} catch {
}
const N = "GET", w = (a) => a && typeof a == "object" ? a : { handle: a };
class b {
  constructor(e, t, s = N) {
    this.handler = w(t), this.match = e, this.method = s;
  }
  setCatchHandler(e) {
    this.catchHandler = w(e);
  }
}
class X extends b {
  constructor(e, t, s) {
    const n = ({ url: i }) => {
      const o = e.exec(i.href);
      if (o && !(i.origin !== location.origin && o.index !== 0))
        return o.slice(1);
    };
    super(n, t, s);
  }
}
class Y {
  constructor() {
    this._routes = /* @__PURE__ */ new Map(), this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  get routes() {
    return this._routes;
  }
  addFetchListener() {
    self.addEventListener("fetch", (e) => {
      const { request: t } = e, s = this.handleRequest({ request: t, event: e });
      s && e.respondWith(s);
    });
  }
  addCacheListener() {
    self.addEventListener("message", (e) => {
      if (e.data && e.data.type === "CACHE_URLS") {
        const { payload: t } = e.data, s = Promise.all(t.urlsToCache.map((n) => {
          typeof n == "string" && (n = [n]);
          const i = new Request(...n);
          return this.handleRequest({ request: i, event: e });
        }));
        e.waitUntil(s), e.ports && e.ports[0] && s.then(() => e.ports[0].postMessage(!0));
      }
    });
  }
  handleRequest({ request: e, event: t }) {
    const s = new URL(e.url, location.href);
    if (!s.protocol.startsWith("http"))
      return;
    const n = s.origin === location.origin, { params: i, route: o } = this.findMatchingRoute({
      event: t,
      request: e,
      sameOrigin: n,
      url: s
    });
    let c = o && o.handler;
    const r = e.method;
    if (!c && this._defaultHandlerMap.has(r) && (c = this._defaultHandlerMap.get(r)), !c)
      return;
    let u;
    try {
      u = c.handle({ url: s, request: e, event: t, params: i });
    } catch (h) {
      u = Promise.reject(h);
    }
    const f = o && o.catchHandler;
    return u instanceof Promise && (this._catchHandler || f) && (u = u.catch(async (h) => {
      if (f)
        try {
          return await f.handle({ url: s, request: e, event: t, params: i });
        } catch (C) {
          C instanceof Error && (h = C);
        }
      if (this._catchHandler)
        return this._catchHandler.handle({ url: s, request: e, event: t });
      throw h;
    })), u;
  }
  findMatchingRoute({ url: e, sameOrigin: t, request: s, event: n }) {
    const i = this._routes.get(s.method) || [];
    for (const o of i) {
      let c;
      const r = o.match({ url: e, sameOrigin: t, request: s, event: n });
      if (r)
        return c = r, (Array.isArray(c) && c.length === 0 || r.constructor === Object && Object.keys(r).length === 0 || typeof r == "boolean") && (c = void 0), { route: o, params: c };
    }
    return {};
  }
  setDefaultHandler(e, t = N) {
    this._defaultHandlerMap.set(t, w(e));
  }
  setCatchHandler(e) {
    this._catchHandler = w(e);
  }
  registerRoute(e) {
    this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e);
  }
  unregisterRoute(e) {
    if (!this._routes.has(e.method))
      throw new l("unregister-route-but-not-found-with-method", {
        method: e.method
      });
    const t = this._routes.get(e.method).indexOf(e);
    if (t > -1)
      this._routes.get(e.method).splice(t, 1);
    else
      throw new l("unregister-route-route-not-registered");
  }
}
let g;
const ee = () => (g || (g = new Y(), g.addFetchListener(), g.addCacheListener()), g);
function te(a, e, t) {
  let s;
  if (typeof a == "string") {
    const i = new URL(a, location.href), o = ({ url: c }) => c.href === i.href;
    s = new b(o, e, t);
  } else if (a instanceof RegExp)
    s = new X(a, e, t);
  else if (typeof a == "function")
    s = new b(a, e, t);
  else if (a instanceof b)
    s = a;
  else
    throw new l("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  return ee().registerRoute(s), s;
}
function se(a, e = []) {
  for (const t of [...a.searchParams.keys()])
    e.some((s) => s.test(t)) && a.searchParams.delete(t);
  return a;
}
function* ae(a, { ignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/], directoryIndex: t = "index.html", cleanURLs: s = !0, urlManipulation: n } = {}) {
  const i = new URL(a, location.href);
  i.hash = "", yield i.href;
  const o = se(i, e);
  if (yield o.href, t && o.pathname.endsWith("/")) {
    const c = new URL(o.href);
    c.pathname += t, yield c.href;
  }
  if (s) {
    const c = new URL(o.href);
    c.pathname += ".html", yield c.href;
  }
  if (n) {
    const c = n({ url: i });
    for (const r of c)
      yield r.href;
  }
}
class ne extends b {
  constructor(e, t) {
    const s = ({ request: n }) => {
      const i = e.getURLsToCacheKeys();
      for (const o of ae(n.url, t)) {
        const c = i.get(o);
        if (c) {
          const r = e.getIntegrityForCacheKey(c);
          return { cacheKey: c, integrity: r };
        }
      }
    };
    super(s, e.strategy);
  }
}
function ie(a) {
  const e = K(), t = new ne(e, a);
  te(t);
}
const oe = "-precache-", ce = async (a, e = oe) => {
  const s = (await self.caches.keys()).filter((n) => n.includes(e) && n.includes(self.registration.scope) && n !== a);
  return await Promise.all(s.map((n) => self.caches.delete(n))), s;
};
function re() {
  self.addEventListener("activate", (a) => {
    const e = y.getPrecacheName();
    a.waitUntil(ce(e).then((t) => {
    }));
  });
}
function le(a) {
  K().precache(a);
}
function ue(a, e) {
  le(a), ie(e);
}
console.log("Hello from service-worker.js", { build: U, files: x, prerendered: L, version: T });
const P = [...x, ...L, ...U].filter((a) => !a.endsWith(".jpeg") && !a.endsWith(".jpg") && !a.endsWith(".avif") && !a.endsWith(".webp") && !a.endsWith(".png") && !a.endsWith(".pdf")).filter((a) => !a.startsWith("/."));
console.log("Service worker urls: ", P);
ue(
  P.map((a) => ({
    url: a,
    revision: T
  })),
  {
    cleanURLs: !1
  }
);
re();
self.addEventListener("install", () => {
  self.skipWaiting();
});
