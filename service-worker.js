const e = /* @__PURE__ */ location.pathname.split("/").slice(0, -1).join("/"), x = [
  e + "/internal/immutable/entry/app.b1c60551.js",
  e + "/internal/immutable/nodes/0.7e7b4873.js",
  e + "/internal/immutable/nodes/1.0c96cc0d.js",
  e + "/internal/immutable/nodes/10.1a376734.js",
  e + "/internal/immutable/nodes/11.71ceddfa.js",
  e + "/internal/immutable/nodes/2.d58925e5.js",
  e + "/internal/immutable/assets/3.b36e2b9b.css",
  e + "/internal/immutable/nodes/3.8979f903.js",
  e + "/internal/immutable/assets/4.37520391.css",
  e + "/internal/immutable/nodes/4.65040699.js",
  e + "/internal/immutable/nodes/5.1fa7df8c.js",
  e + "/internal/immutable/nodes/6.1fa7df8c.js",
  e + "/internal/immutable/assets/7.defec1af.css",
  e + "/internal/immutable/nodes/7.a53abc91.js",
  e + "/internal/immutable/assets/github-markdown.f7458399.css",
  e + "/internal/immutable/assets/8.1a64439c.css",
  e + "/internal/immutable/nodes/8.85f6acab.js",
  e + "/internal/immutable/assets/9.42a5e5d1.css",
  e + "/internal/immutable/nodes/9.029b9b04.js",
  e + "/internal/immutable/assets/2.1b24a0f8.css",
  e + "/internal/immutable/assets/Face.a1686178.css",
  e + "/internal/immutable/assets/MeCard.f7e3211b.css",
  e + "/internal/immutable/chunks/2.303af541.js",
  e + "/internal/immutable/chunks/CardNavigation.aebfd97f.js",
  e + "/internal/immutable/chunks/Face.23dcf298.js",
  e + "/internal/immutable/chunks/Icon.5aff6c4a.js",
  e + "/internal/immutable/chunks/MeCard.c5444cf1.js",
  e + "/internal/immutable/chunks/_post.db30aed6.js",
  e + "/internal/immutable/assets/_post.4ada946d.css",
  e + "/internal/immutable/chunks/animationSetup.e5fdeec9.js",
  e + "/internal/immutable/chunks/app.e0cffb4e.js",
  e + "/internal/immutable/assets/app.5bee3c1a.css",
  e + "/internal/immutable/chunks/control.e7f5239e.js",
  e + "/internal/immutable/chunks/home.39fc25a5.js",
  e + "/internal/immutable/chunks/images.dff1384d.js",
  e + "/internal/immutable/chunks/index.5ac61fbc.js",
  e + "/internal/immutable/chunks/index.864269ae.js",
  e + "/internal/immutable/chunks/index.ef1416e5.js",
  e + "/internal/immutable/chunks/list.97459fba.js",
  e + "/internal/immutable/chunks/mail.912f8807.js",
  e + "/internal/immutable/chunks/preload-helper.41c905a7.js",
  e + "/internal/immutable/chunks/singletons.464ad52c.js",
  e + "/internal/immutable/chunks/store.86ff4d65.js",
  e + "/internal/immutable/chunks/stores.9ff1d2e3.js",
  e + "/internal/immutable/chunks/unwriteEffect.a2f37219.js",
  e + "/internal/immutable/chunks/writeAndUnwriteText.21a04a81.js",
  e + "/internal/immutable/chunks/writeEffect.b8b30749.js",
  e + "/internal/immutable/entry/start.86e01ad2.js",
  e + "/internal/immutable/chunks/giscus.ca6d4cb8.js",
  e + "/internal/immutable/chunks/index.f6794a94.js",
  e + "/internal/immutable/chunks/cascade.7f9e6450.js",
  e + "/internal/immutable/chunks/concurrent.38f1925b.js",
  e + "/internal/immutable/chunks/loop.f52356d8.js",
  e + "/internal/immutable/chunks/loopOnce.1cb35b35.js",
  e + "/internal/immutable/chunks/loopRandom.b8cdfe6b.js",
  e + "/internal/immutable/chunks/scramble.c7e563bc.js",
  e + "/internal/immutable/chunks/emojik-es-a-windows.d43ddaae.js",
  e + "/internal/immutable/chunks/hidden-post.8bb4686e.js",
  e + "/internal/immutable/chunks/welcome.1a24a9fe.js",
  e + "/internal/immutable/chunks/ASZEV2022.25f85271.js",
  e + "/internal/immutable/assets/ASZEV2022.89e1cc38.jpeg",
  e + "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2019.7627fc48.js",
  e + "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2019.93acf6d0.jpeg",
  e + "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2020.391c838e.js",
  e + "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2020.2b678c79.jpeg",
  e + "/internal/immutable/chunks/Bakonyi-Bitfarago-Bajnoksag-2021.dbfe2027.js",
  e + "/internal/immutable/assets/Bakonyi-Bitfarago-Bajnoksag-2021.de46e89f.jpeg",
  e + "/internal/immutable/chunks/Dusza-2019.442e4fb5.js",
  e + "/internal/immutable/assets/Dusza-2019.35684b17.jpeg",
  e + "/internal/immutable/chunks/Dusza-2020.4f65a298.js",
  e + "/internal/immutable/assets/Dusza-2020.45830cb7.jpeg",
  e + "/internal/immutable/chunks/Dusza-mobil-2019.32abf134.js",
  e + "/internal/immutable/assets/Dusza-mobil-2019.721cb137.jpeg",
  e + "/internal/immutable/chunks/Dusza-mobil-2020.1ed003e1.js",
  e + "/internal/immutable/assets/Dusza-mobil-2020.fd3b6a24.jpeg",
  e + "/internal/immutable/chunks/Dusza-mobil-2021.1fac1b26.js",
  e + "/internal/immutable/assets/Dusza-mobil-2021.9a8ceeb4.jpeg",
  e + "/internal/immutable/chunks/Ifju-Tudosok-2022.0acdf6f2.js",
  e + "/internal/immutable/assets/Ifju-Tudosok-2022.66758e93.jpeg",
  e + "/internal/immutable/chunks/Innovacios-tehetsegkutato-2020.735302af.js",
  e + "/internal/immutable/assets/Innovacios-tehetsegkutato-2020.57e8b332.jpeg",
  e + "/internal/immutable/chunks/Innovacios-tehetsegkutato-2021.f68d9103.js",
  e + "/internal/immutable/assets/Innovacios-tehetsegkutato-2021.e24552e1.jpeg",
  e + "/internal/immutable/chunks/Iskola-programozas-verseny-2018.a3c96281.js",
  e + "/internal/immutable/assets/Iskola-programozas-verseny-2018.3f5ff933.jpeg",
  e + "/internal/immutable/chunks/Kodolj-Hatarok-Nelkul-2020.968523b1.js",
  e + "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2020.bbd8c8ca.jpeg",
  e + "/internal/immutable/chunks/Kodolj-Hatarok-Nelkul-2021.ef6b38a2.js",
  e + "/internal/immutable/assets/Kodolj-Hatarok-Nelkul-2021.2a73ea96.jpeg",
  e + "/internal/immutable/chunks/Merklik-2021.7f787a77.js",
  e + "/internal/immutable/assets/Merklik-2021.c483c600.jpeg",
  e + "/internal/immutable/chunks/Nemes-Tihamer-2019.ce600e49.js",
  e + "/internal/immutable/assets/Nemes-Tihamer-2019.259bb313.jpeg",
  e + "/internal/immutable/chunks/SZIIV-2019.fa9e1566.js",
  e + "/internal/immutable/assets/SZIIV-2019.c3c1339f.jpeg",
  e + "/internal/immutable/chunks/SZIIV-2020.83e5778d.js",
  e + "/internal/immutable/assets/SZIIV-2020.8240b8b4.jpeg",
  e + "/internal/immutable/chunks/Skills-Junior-Web-2022.3b1d5a77.js",
  e + "/internal/immutable/assets/Skills-Junior-Web-2022.4fbac8e3.jpeg",
  e + "/internal/immutable/chunks/Webex-Teams-Hackathlon-2019-photo.1a2a1529.js",
  e + "/internal/immutable/assets/Webex-Teams-Hackathlon-2019-photo.d924e58a.jpeg",
  e + "/internal/immutable/chunks/sk.19136d60.js",
  e + "/internal/immutable/assets/sk.c01ce8fa.jpeg",
  e + "/internal/immutable/chunks/unknownhe.b5be5a5b.js",
  e + "/internal/immutable/assets/unknownhe.54c4279e.jpeg"
], T = [
  e + "/.nojekyll",
  e + "/android-chrome-192x192.png",
  e + "/android-chrome-512x512.png",
  e + "/apple-touch-icon.png",
  e + "/assets/card/windmill.svg",
  e + "/assets/certificates/CCNA-1-certificate.pdf",
  e + "/assets/certificates/CCNA-2-certificate.pdf",
  e + "/assets/competitions/ASZEV2022.jpeg",
  e + "/assets/competitions/Accenture Java 2020.pdf",
  e + "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.jpeg",
  e + "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.jpeg",
  e + "/assets/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.jpeg",
  e + "/assets/competitions/Dusza-2019.jpeg",
  e + "/assets/competitions/Dusza-2020.jpeg",
  e + "/assets/competitions/Dusza-mobil-2019.jpeg",
  e + "/assets/competitions/Dusza-mobil-2020.jpeg",
  e + "/assets/competitions/Dusza-mobil-2021.jpeg",
  e + "/assets/competitions/GAMF programoz√≥ verseny 2020.pdf",
  e + "/assets/competitions/Ifju-Tudosok-2022.jpeg",
  e + "/assets/competitions/Innovacios-tehetsegkutato-2020.jpeg",
  e + "/assets/competitions/Innovacios-tehetsegkutato-2021.jpeg",
  e + "/assets/competitions/Iskola-programozas-verseny-2018.jpeg",
  e + "/assets/competitions/Kodolj-Hatarok-Nelkul-2020.jpeg",
  e + "/assets/competitions/Kodolj-Hatarok-Nelkul-2021.jpeg",
  e + "/assets/competitions/Merklik-2021.jpeg",
  e + "/assets/competitions/Nemes-Tihamer-2019.jpeg",
  e + "/assets/competitions/Nemes-Tihamer-2020.pdf",
  e + "/assets/competitions/SZIIV-2019.jpeg",
  e + "/assets/competitions/SZIIV-2020.jpeg",
  e + "/assets/competitions/Skills-Junior-Web-2022.jpeg",
  e + "/assets/competitions/Webex-Teams-Hackathlon-2019-photo.jpeg",
  e + "/assets/og-banner.jpg",
  e + "/assets/people/sk.jpeg",
  e + "/assets/people/unknownhe.jpeg",
  e + "/assets/posts/yt1f9UbfqqHlknfx-image-1653148385384.png",
  e + "/business-card-back.template.svg",
  e + "/business-card-front.template.svg",
  e + "/favicon-16x16.png",
  e + "/favicon-32x32.png",
  e + "/favicon.ico",
  e + "/manifest.json",
  e + "/readme.template.md",
  e + "/robots.txt"
], B = [
  e + "/",
  e + "/shlinks/---.txt",
  e + "/404",
  e + "/shlinks/---404.txt",
  e + "/business-card-back.svg",
  e + "/business-card-front.svg",
  e + "/card",
  e + "/shlinks/---card.txt",
  e + "/me-card-wrapped",
  e + "/shlinks/---me-card-wrapped.txt",
  e + "/me",
  e + "/shlinks/---me.txt",
  e + "/posts.json",
  e + "/posts",
  e + "/shlinks/---posts.txt",
  e + "/readme.md",
  e + "/readme",
  e + "/shlinks/---readme.txt",
  e + "/readme/__data.json",
  e + "/rss.xml",
  e + "/sitemap.xml",
  e + "/posts/emojik-es-a-windows",
  e + "/shlinks/---posts---emojik-es-a-windows.txt",
  e + "/posts/hidden-post",
  e + "/shlinks/---posts---hidden-post.txt",
  e + "/posts/welcome",
  e + "/shlinks/---posts---welcome.txt",
  e + "/images/competitions/ASZEV2022.jpg",
  e + "/images/competitions/ASZEV2022.webp",
  e + "/images/competitions/ASZEV2022.avif",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.jpg",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.webp",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2019.avif",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.jpg",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.webp",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2020.avif",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.jpg",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.webp",
  e + "/images/competitions/Bakonyi-Bitfarago-Bajnoksag-2021.avif",
  e + "/images/competitions/Dusza-2019.jpg",
  e + "/images/competitions/Dusza-2019.webp",
  e + "/images/competitions/Dusza-2019.avif",
  e + "/images/competitions/Dusza-2020.jpg",
  e + "/images/competitions/Dusza-2020.webp",
  e + "/images/competitions/Dusza-2020.avif",
  e + "/images/competitions/Dusza-mobil-2019.jpg",
  e + "/images/competitions/Dusza-mobil-2019.webp",
  e + "/images/competitions/Dusza-mobil-2019.avif",
  e + "/images/competitions/Dusza-mobil-2020.jpg",
  e + "/images/competitions/Dusza-mobil-2020.webp",
  e + "/images/competitions/Dusza-mobil-2020.avif",
  e + "/images/competitions/Dusza-mobil-2021.jpg",
  e + "/images/competitions/Dusza-mobil-2021.webp",
  e + "/images/competitions/Dusza-mobil-2021.avif",
  e + "/images/competitions/Ifju-Tudosok-2022.jpg",
  e + "/images/competitions/Ifju-Tudosok-2022.webp",
  e + "/images/competitions/Ifju-Tudosok-2022.avif",
  e + "/images/competitions/Innovacios-tehetsegkutato-2020.jpg",
  e + "/images/competitions/Innovacios-tehetsegkutato-2020.webp",
  e + "/images/competitions/Innovacios-tehetsegkutato-2020.avif",
  e + "/images/competitions/Innovacios-tehetsegkutato-2021.jpg",
  e + "/images/competitions/Innovacios-tehetsegkutato-2021.webp",
  e + "/images/competitions/Innovacios-tehetsegkutato-2021.avif",
  e + "/images/competitions/Iskola-programozas-verseny-2018.jpg",
  e + "/images/competitions/Iskola-programozas-verseny-2018.webp",
  e + "/images/competitions/Iskola-programozas-verseny-2018.avif",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2020.jpg",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2020.webp",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2020.avif",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2021.jpg",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2021.webp",
  e + "/images/competitions/Kodolj-Hatarok-Nelkul-2021.avif",
  e + "/images/competitions/Merklik-2021.jpg",
  e + "/images/competitions/Merklik-2021.webp",
  e + "/images/competitions/Merklik-2021.avif",
  e + "/images/competitions/Nemes-Tihamer-2019.jpg",
  e + "/images/competitions/Nemes-Tihamer-2019.webp",
  e + "/images/competitions/Nemes-Tihamer-2019.avif",
  e + "/images/competitions/SZIIV-2019.jpg",
  e + "/images/competitions/SZIIV-2019.webp",
  e + "/images/competitions/SZIIV-2019.avif",
  e + "/images/competitions/SZIIV-2020.jpg",
  e + "/images/competitions/SZIIV-2020.webp",
  e + "/images/competitions/SZIIV-2020.avif",
  e + "/images/competitions/Skills-Junior-Web-2022.jpg",
  e + "/images/competitions/Skills-Junior-Web-2022.webp",
  e + "/images/competitions/Skills-Junior-Web-2022.avif",
  e + "/images/competitions/Webex-Teams-Hackathlon-2019-photo.jpg",
  e + "/images/competitions/Webex-Teams-Hackathlon-2019-photo.webp",
  e + "/images/competitions/Webex-Teams-Hackathlon-2019-photo.avif",
  e + "/images/people/sk.jpg",
  e + "/images/people/sk.webp",
  e + "/images/people/sk.avif",
  e + "/images/people/unknownhe.jpg",
  e + "/images/people/unknownhe.webp",
  e + "/images/people/unknownhe.avif"
], K = "1683831534693";
try {
  self["workbox:core:6.5.3"] && _();
} catch {
}
const P = (i, ...t) => {
  let s = i;
  return t.length > 0 && (s += ` :: ${JSON.stringify(t)}`), s;
}, S = P;
class u extends Error {
  /**
   *
   * @param {string} errorCode The error code that
   * identifies this particular error.
   * @param {Object=} details Any relevant arguments
   * that will help developers identify issues should
   * be added as a key on the context object.
   */
  constructor(t, s) {
    const a = S(t, s);
    super(a), this.name = t, this.details = s;
  }
}
const f = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration < "u" ? registration.scope : ""
}, R = (i) => [f.prefix, i, f.suffix].filter((t) => t && t.length > 0).join("-"), W = (i) => {
  for (const t of Object.keys(f))
    i(t);
}, y = {
  updateDetails: (i) => {
    W((t) => {
      typeof i[t] == "string" && (f[t] = i[t]);
    });
  },
  getGoogleAnalyticsName: (i) => i || R(f.googleAnalytics),
  getPrecacheName: (i) => i || R(f.precache),
  getPrefix: () => f.prefix,
  getRuntimeName: (i) => i || R(f.runtime),
  getSuffix: () => f.suffix
};
function I(i, t) {
  const s = t();
  return i.waitUntil(s), s;
}
try {
  self["workbox:precaching:6.5.3"] && _();
} catch {
}
const E = "__WB_REVISION__";
function H(i) {
  if (!i)
    throw new u("add-to-cache-list-unexpected-type", { entry: i });
  if (typeof i == "string") {
    const o = new URL(i, location.href);
    return {
      cacheKey: o.href,
      url: o.href
    };
  }
  const { revision: t, url: s } = i;
  if (!s)
    throw new u("add-to-cache-list-unexpected-type", { entry: i });
  if (!t) {
    const o = new URL(s, location.href);
    return {
      cacheKey: o.href,
      url: o.href
    };
  }
  const a = new URL(s, location.href), n = new URL(s, location.href);
  return a.searchParams.set(E, t), {
    cacheKey: a.href,
    url: n.href
  };
}
class z {
  constructor() {
    this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: t, state: s }) => {
      s && (s.originalRequest = t);
    }, this.cachedResponseWillBeUsed = async ({ event: t, state: s, cachedResponse: a }) => {
      if (t.type === "install" && s && s.originalRequest && s.originalRequest instanceof Request) {
        const n = s.originalRequest.url;
        a ? this.notUpdatedURLs.push(n) : this.updatedURLs.push(n);
      }
      return a;
    };
  }
}
class M {
  constructor({ precacheController: t }) {
    this.cacheKeyWillBeUsed = async ({ request: s, params: a }) => {
      const n = (a == null ? void 0 : a.cacheKey) || this._precacheController.getCacheKeyForURL(s.url);
      return n ? new Request(n, { headers: s.headers }) : s;
    }, this._precacheController = t;
  }
}
let d;
function O() {
  if (d === void 0) {
    const i = new Response("");
    if ("body" in i)
      try {
        new Response(i.body), d = !0;
      } catch {
        d = !1;
      }
    d = !1;
  }
  return d;
}
async function A(i, t) {
  let s = null;
  if (i.url && (s = new URL(i.url).origin), s !== self.location.origin)
    throw new u("cross-origin-copy-response", { origin: s });
  const a = i.clone(), n = {
    headers: new Headers(a.headers),
    status: a.status,
    statusText: a.statusText
  }, o = t ? t(n) : n, c = O() ? a.body : await a.blob();
  return new Response(c, o);
}
const q = (i) => new URL(String(i), location.href).href.replace(new RegExp(`^${location.origin}`), "");
function U(i, t) {
  const s = new URL(i);
  for (const a of t)
    s.searchParams.delete(a);
  return s.href;
}
async function F(i, t, s, a) {
  const n = U(t.url, s);
  if (t.url === n)
    return i.match(t, a);
  const o = Object.assign(Object.assign({}, a), { ignoreSearch: !0 }), c = await i.keys(t, o);
  for (const r of c) {
    const l = U(r.url, s);
    if (n === l)
      return i.match(r, a);
  }
}
class V {
  /**
   * Creates a promise and exposes its resolve and reject functions as methods.
   */
  constructor() {
    this.promise = new Promise((t, s) => {
      this.resolve = t, this.reject = s;
    });
  }
}
const Z = /* @__PURE__ */ new Set();
async function J() {
  for (const i of Z)
    await i();
}
function $(i) {
  return new Promise((t) => setTimeout(t, i));
}
try {
  self["workbox:strategies:6.5.3"] && _();
} catch {
}
function j(i) {
  return typeof i == "string" ? new Request(i) : i;
}
class G {
  /**
   * Creates a new instance associated with the passed strategy and event
   * that's handling the request.
   *
   * The constructor also initializes the state that will be passed to each of
   * the plugins handling this request.
   *
   * @param {workbox-strategies.Strategy} strategy
   * @param {Object} options
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params] The return value from the
   *     {@link workbox-routing~matchCallback} (if applicable).
   */
  constructor(t, s) {
    this._cacheKeys = {}, Object.assign(this, s), this.event = s.event, this._strategy = t, this._handlerDeferred = new V(), this._extendLifetimePromises = [], this._plugins = [...t.plugins], this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const a of this._plugins)
      this._pluginStateMap.set(a, {});
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  /**
   * Fetches a given request (and invokes any applicable plugin callback
   * methods) using the `fetchOptions` (for non-navigation requests) and
   * `plugins` defined on the `Strategy` object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - `requestWillFetch()`
   * - `fetchDidSucceed()`
   * - `fetchDidFail()`
   *
   * @param {Request|string} input The URL or request to fetch.
   * @return {Promise<Response>}
   */
  async fetch(t) {
    const { event: s } = this;
    let a = j(t);
    if (a.mode === "navigate" && s instanceof FetchEvent && s.preloadResponse) {
      const c = await s.preloadResponse;
      if (c)
        return c;
    }
    const n = this.hasCallback("fetchDidFail") ? a.clone() : null;
    try {
      for (const c of this.iterateCallbacks("requestWillFetch"))
        a = await c({ request: a.clone(), event: s });
    } catch (c) {
      if (c instanceof Error)
        throw new u("plugin-error-request-will-fetch", {
          thrownErrorMessage: c.message
        });
    }
    const o = a.clone();
    try {
      let c;
      c = await fetch(a, a.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
      for (const r of this.iterateCallbacks("fetchDidSucceed"))
        c = await r({
          event: s,
          request: o,
          response: c
        });
      return c;
    } catch (c) {
      throw n && await this.runCallbacks("fetchDidFail", {
        error: c,
        event: s,
        originalRequest: n.clone(),
        request: o.clone()
      }), c;
    }
  }
  /**
   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
   * the response generated by `this.fetch()`.
   *
   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
   * so you do not have to manually call `waitUntil()` on the event.
   *
   * @param {Request|string} input The request or URL to fetch and cache.
   * @return {Promise<Response>}
   */
  async fetchAndCachePut(t) {
    const s = await this.fetch(t), a = s.clone();
    return this.waitUntil(this.cachePut(t, a)), s;
  }
  /**
   * Matches a request from the cache (and invokes any applicable plugin
   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
   * defined on the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillByUsed()
   * - cachedResponseWillByUsed()
   *
   * @param {Request|string} key The Request or URL to use as the cache key.
   * @return {Promise<Response|undefined>} A matching response, if found.
   */
  async cacheMatch(t) {
    const s = j(t);
    let a;
    const { cacheName: n, matchOptions: o } = this._strategy, c = await this.getCacheKey(s, "read"), r = Object.assign(Object.assign({}, o), { cacheName: n });
    a = await caches.match(c, r);
    for (const l of this.iterateCallbacks("cachedResponseWillBeUsed"))
      a = await l({
        cacheName: n,
        matchOptions: o,
        cachedResponse: a,
        request: c,
        event: this.event
      }) || void 0;
    return a;
  }
  /**
   * Puts a request/response pair in the cache (and invokes any applicable
   * plugin callback methods) using the `cacheName` and `plugins` defined on
   * the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillByUsed()
   * - cacheWillUpdate()
   * - cacheDidUpdate()
   *
   * @param {Request|string} key The request or URL to use as the cache key.
   * @param {Response} response The response to cache.
   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
   * not be cached, and `true` otherwise.
   */
  async cachePut(t, s) {
    const a = j(t);
    await $(0);
    const n = await this.getCacheKey(a, "write");
    if (!s)
      throw new u("cache-put-with-no-response", {
        url: q(n.url)
      });
    const o = await this._ensureResponseSafeToCache(s);
    if (!o)
      return !1;
    const { cacheName: c, matchOptions: r } = this._strategy, l = await self.caches.open(c), h = this.hasCallback("cacheDidUpdate"), g = h ? await F(
      // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
      // feature. Consider into ways to only add this behavior if using
      // precaching.
      l,
      n.clone(),
      ["__WB_REVISION__"],
      r
    ) : null;
    try {
      await l.put(n, h ? o.clone() : o);
    } catch (m) {
      if (m instanceof Error)
        throw m.name === "QuotaExceededError" && await J(), m;
    }
    for (const m of this.iterateCallbacks("cacheDidUpdate"))
      await m({
        cacheName: c,
        oldResponse: g,
        newResponse: o.clone(),
        request: n,
        event: this.event
      });
    return !0;
  }
  /**
   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
   * executes any of those callbacks found in sequence. The final `Request`
   * object returned by the last plugin is treated as the cache key for cache
   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
   * been registered, the passed request is returned unmodified
   *
   * @param {Request} request
   * @param {string} mode
   * @return {Promise<Request>}
   */
  async getCacheKey(t, s) {
    const a = `${t.url} | ${s}`;
    if (!this._cacheKeys[a]) {
      let n = t;
      for (const o of this.iterateCallbacks("cacheKeyWillBeUsed"))
        n = j(await o({
          mode: s,
          request: n,
          event: this.event,
          // params has a type any can't change right now.
          params: this.params
          // eslint-disable-line
        }));
      this._cacheKeys[a] = n;
    }
    return this._cacheKeys[a];
  }
  /**
   * Returns true if the strategy has at least one plugin with the given
   * callback.
   *
   * @param {string} name The name of the callback to check for.
   * @return {boolean}
   */
  hasCallback(t) {
    for (const s of this._strategy.plugins)
      if (t in s)
        return !0;
    return !1;
  }
  /**
   * Runs all plugin callbacks matching the given name, in order, passing the
   * given param object (merged ith the current plugin state) as the only
   * argument.
   *
   * Note: since this method runs all plugins, it's not suitable for cases
   * where the return value of a callback needs to be applied prior to calling
   * the next callback. See
   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
   * below for how to handle that case.
   *
   * @param {string} name The name of the callback to run within each plugin.
   * @param {Object} param The object to pass as the first (and only) param
   *     when executing each callback. This object will be merged with the
   *     current plugin state prior to callback execution.
   */
  async runCallbacks(t, s) {
    for (const a of this.iterateCallbacks(t))
      await a(s);
  }
  /**
   * Accepts a callback and returns an iterable of matching plugin callbacks,
   * where each callback is wrapped with the current handler state (i.e. when
   * you call each callback, whatever object parameter you pass it will
   * be merged with the plugin's current state).
   *
   * @param {string} name The name fo the callback to run
   * @return {Array<Function>}
   */
  *iterateCallbacks(t) {
    for (const s of this._strategy.plugins)
      if (typeof s[t] == "function") {
        const a = this._pluginStateMap.get(s);
        yield (o) => {
          const c = Object.assign(Object.assign({}, o), { state: a });
          return s[t](c);
        };
      }
  }
  /**
   * Adds a promise to the
   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
   * of the event event associated with the request being handled (usually a
   * `FetchEvent`).
   *
   * Note: you can await
   * {@link workbox-strategies.StrategyHandler~doneWaiting}
   * to know when all added promises have settled.
   *
   * @param {Promise} promise A promise to add to the extend lifetime promises
   *     of the event that triggered the request.
   */
  waitUntil(t) {
    return this._extendLifetimePromises.push(t), t;
  }
  /**
   * Returns a promise that resolves once all promises passed to
   * {@link workbox-strategies.StrategyHandler~waitUntil}
   * have settled.
   *
   * Note: any work done after `doneWaiting()` settles should be manually
   * passed to an event's `waitUntil()` method (not this handler's
   * `waitUntil()` method), otherwise the service worker thread my be killed
   * prior to your work completing.
   */
  async doneWaiting() {
    let t;
    for (; t = this._extendLifetimePromises.shift(); )
      await t;
  }
  /**
   * Stops running the strategy and immediately resolves any pending
   * `waitUntil()` promises.
   */
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  /**
   * This method will call cacheWillUpdate on the available plugins (or use
   * status === 200) to determine if the Response is safe and valid to cache.
   *
   * @param {Request} options.request
   * @param {Response} options.response
   * @return {Promise<Response|undefined>}
   *
   * @private
   */
  async _ensureResponseSafeToCache(t) {
    let s = t, a = !1;
    for (const n of this.iterateCallbacks("cacheWillUpdate"))
      if (s = await n({
        request: this.request,
        response: s,
        event: this.event
      }) || void 0, a = !0, !s)
        break;
    return a || s && s.status !== 200 && (s = void 0), s;
  }
}
class Q {
  /**
   * Creates a new instance of the strategy and sets all documented option
   * properties as public instance properties.
   *
   * Note: if a custom strategy class extends the base Strategy class and does
   * not need more than these properties, it does not need to define its own
   * constructor.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   */
  constructor(t = {}) {
    this.cacheName = y.getRuntimeName(t.cacheName), this.plugins = t.plugins || [], this.fetchOptions = t.fetchOptions, this.matchOptions = t.matchOptions;
  }
  /**
   * Perform a request strategy and returns a `Promise` that will resolve with
   * a `Response`, invoking all relevant plugin callbacks.
   *
   * When a strategy instance is registered with a Workbox
   * {@link workbox-routing.Route}, this method is automatically
   * called when the route matches.
   *
   * Alternatively, this method can be used in a standalone `FetchEvent`
   * listener by passing it to `event.respondWith()`.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   */
  handle(t) {
    const [s] = this.handleAll(t);
    return s;
  }
  /**
   * Similar to {@link workbox-strategies.Strategy~handle}, but
   * instead of just returning a `Promise` that resolves to a `Response` it
   * it will return an tuple of `[response, done]` promises, where the former
   * (`response`) is equivalent to what `handle()` returns, and the latter is a
   * Promise that will resolve once any promises that were added to
   * `event.waitUntil()` as part of performing the strategy have completed.
   *
   * You can await the `done` promise to ensure any extra work performed by
   * the strategy (usually caching responses) completes successfully.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   * @return {Array<Promise>} A tuple of [response, done]
   *     promises that can be used to determine when the response resolves as
   *     well as when the handler has completed all its work.
   */
  handleAll(t) {
    t instanceof FetchEvent && (t = {
      event: t,
      request: t.request
    });
    const s = t.event, a = typeof t.request == "string" ? new Request(t.request) : t.request, n = "params" in t ? t.params : void 0, o = new G(this, { event: s, request: a, params: n }), c = this._getResponse(o, a, s), r = this._awaitComplete(c, o, a, s);
    return [c, r];
  }
  async _getResponse(t, s, a) {
    await t.runCallbacks("handlerWillStart", { event: a, request: s });
    let n;
    try {
      if (n = await this._handle(s, t), !n || n.type === "error")
        throw new u("no-response", { url: s.url });
    } catch (o) {
      if (o instanceof Error) {
        for (const c of t.iterateCallbacks("handlerDidError"))
          if (n = await c({ error: o, event: a, request: s }), n)
            break;
      }
      if (!n)
        throw o;
    }
    for (const o of t.iterateCallbacks("handlerWillRespond"))
      n = await o({ event: a, request: s, response: n });
    return n;
  }
  async _awaitComplete(t, s, a, n) {
    let o, c;
    try {
      o = await t;
    } catch {
    }
    try {
      await s.runCallbacks("handlerDidRespond", {
        event: n,
        request: a,
        response: o
      }), await s.doneWaiting();
    } catch (r) {
      r instanceof Error && (c = r);
    }
    if (await s.runCallbacks("handlerDidComplete", {
      event: n,
      request: a,
      response: o,
      error: c
    }), s.destroy(), c)
      throw c;
  }
}
class p extends Q {
  /**
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
   * of all fetch() requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor(t = {}) {
    t.cacheName = y.getPrecacheName(t.cacheName), super(t), this._fallbackToNetwork = t.fallbackToNetwork !== !1, this.plugins.push(p.copyRedirectedCacheableResponsesPlugin);
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(t, s) {
    const a = await s.cacheMatch(t);
    return a || (s.event && s.event.type === "install" ? await this._handleInstall(t, s) : await this._handleFetch(t, s));
  }
  async _handleFetch(t, s) {
    let a;
    const n = s.params || {};
    if (this._fallbackToNetwork) {
      const o = n.integrity, c = t.integrity, r = !c || c === o;
      a = await s.fetch(new Request(t, {
        integrity: t.mode !== "no-cors" ? c || o : void 0
      })), o && r && t.mode !== "no-cors" && (this._useDefaultCacheabilityPluginIfNeeded(), await s.cachePut(t, a.clone()));
    } else
      throw new u("missing-precache-entry", {
        cacheName: this.cacheName,
        url: t.url
      });
    return a;
  }
  async _handleInstall(t, s) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const a = await s.fetch(t);
    if (!await s.cachePut(t, a.clone()))
      throw new u("bad-precaching-response", {
        url: t.url,
        status: a.status
      });
    return a;
  }
  /**
   * This method is complex, as there a number of things to account for:
   *
   * The `plugins` array can be set at construction, and/or it might be added to
   * to at any time before the strategy is used.
   *
   * At the time the strategy is used (i.e. during an `install` event), there
   * needs to be at least one plugin that implements `cacheWillUpdate` in the
   * array, other than `copyRedirectedCacheableResponsesPlugin`.
   *
   * - If this method is called and there are no suitable `cacheWillUpdate`
   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
   *
   * - If this method is called and there is exactly one `cacheWillUpdate`, then
   * we don't have to do anything (this might be a previously added
   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
   *
   * - If this method is called and there is more than one `cacheWillUpdate`,
   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
   * we need to remove it. (This situation is unlikely, but it could happen if
   * the strategy is used multiple times, the first without a `cacheWillUpdate`,
   * and then later on after manually adding a custom `cacheWillUpdate`.)
   *
   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
   *
   * @private
   */
  _useDefaultCacheabilityPluginIfNeeded() {
    let t = null, s = 0;
    for (const [a, n] of this.plugins.entries())
      n !== p.copyRedirectedCacheableResponsesPlugin && (n === p.defaultPrecacheCacheabilityPlugin && (t = a), n.cacheWillUpdate && s++);
    s === 0 ? this.plugins.push(p.defaultPrecacheCacheabilityPlugin) : s > 1 && t !== null && this.plugins.splice(t, 1);
  }
}
p.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response: i }) {
    return !i || i.status >= 400 ? null : i;
  }
};
p.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response: i }) {
    return i.redirected ? await A(i) : i;
  }
};
class X {
  /**
   * Create a new PrecacheController.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] The cache to use for precaching.
   * @param {string} [options.plugins] Plugins to use when precaching as well
   * as responding to fetch events for precached assets.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor({ cacheName: t, plugins: s = [], fallbackToNetwork: a = !0 } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map(), this._urlsToCacheModes = /* @__PURE__ */ new Map(), this._cacheKeysToIntegrities = /* @__PURE__ */ new Map(), this._strategy = new p({
      cacheName: y.getPrecacheName(t),
      plugins: [
        ...s,
        new M({ precacheController: this })
      ],
      fallbackToNetwork: a
    }), this.install = this.install.bind(this), this.activate = this.activate.bind(this);
  }
  /**
   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
   * used to cache assets and respond to fetch events.
   */
  get strategy() {
    return this._strategy;
  }
  /**
   * Adds items to the precache list, removing any duplicates and
   * stores the files in the
   * {@link workbox-core.cacheNames|"precache cache"} when the service
   * worker installs.
   *
   * This method can be called multiple times.
   *
   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
   */
  precache(t) {
    this.addToCacheList(t), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0);
  }
  /**
   * This method will add items to the precache list, removing duplicates
   * and ensuring the information is valid.
   *
   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
   *     Array of entries to precache.
   */
  addToCacheList(t) {
    const s = [];
    for (const a of t) {
      typeof a == "string" ? s.push(a) : a && a.revision === void 0 && s.push(a.url);
      const { cacheKey: n, url: o } = H(a), c = typeof a != "string" && a.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(o) && this._urlsToCacheKeys.get(o) !== n)
        throw new u("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(o),
          secondEntry: n
        });
      if (typeof a != "string" && a.integrity) {
        if (this._cacheKeysToIntegrities.has(n) && this._cacheKeysToIntegrities.get(n) !== a.integrity)
          throw new u("add-to-cache-list-conflicting-integrities", {
            url: o
          });
        this._cacheKeysToIntegrities.set(n, a.integrity);
      }
      if (this._urlsToCacheKeys.set(o, n), this._urlsToCacheModes.set(o, c), s.length > 0) {
        const r = `Workbox is precaching URLs without revision info: ${s.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        console.warn(r);
      }
    }
  }
  /**
   * Precaches new and updated assets. Call this method from the service worker
   * install event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.InstallResult>}
   */
  install(t) {
    return I(t, async () => {
      const s = new z();
      this.strategy.plugins.push(s);
      for (const [o, c] of this._urlsToCacheKeys) {
        const r = this._cacheKeysToIntegrities.get(c), l = this._urlsToCacheModes.get(o), h = new Request(o, {
          integrity: r,
          cache: l,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey: c },
          request: h,
          event: t
        }));
      }
      const { updatedURLs: a, notUpdatedURLs: n } = s;
      return { updatedURLs: a, notUpdatedURLs: n };
    });
  }
  /**
   * Deletes assets that are no longer present in the current precache manifest.
   * Call this method from the service worker activate event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.CleanupResult>}
   */
  activate(t) {
    return I(t, async () => {
      const s = await self.caches.open(this.strategy.cacheName), a = await s.keys(), n = new Set(this._urlsToCacheKeys.values()), o = [];
      for (const c of a)
        n.has(c.url) || (await s.delete(c), o.push(c.url));
      return { deletedURLs: o };
    });
  }
  /**
   * Returns a mapping of a precached URL to the corresponding cache key, taking
   * into account the revision information for the URL.
   *
   * @return {Map<string, string>} A URL to cache key mapping.
   */
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  /**
   * Returns a list of all the URLs that have been precached by the current
   * service worker.
   *
   * @return {Array<string>} The precached URLs.
   */
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  /**
   * Returns the cache key used for storing a given URL. If that URL is
   * unversioned, like `/index.html', then the cache key will be the original
   * URL with a search parameter appended to it.
   *
   * @param {string} url A URL whose cache key you want to look up.
   * @return {string} The versioned URL that corresponds to a cache key
   * for the original URL, or undefined if that URL isn't precached.
   */
  getCacheKeyForURL(t) {
    const s = new URL(t, location.href);
    return this._urlsToCacheKeys.get(s.href);
  }
  /**
   * @param {string} url A cache key whose SRI you want to look up.
   * @return {string} The subresource integrity associated with the cache key,
   * or undefined if it's not set.
   */
  getIntegrityForCacheKey(t) {
    return this._cacheKeysToIntegrities.get(t);
  }
  /**
   * This acts as a drop-in replacement for
   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
   * with the following differences:
   *
   * - It knows what the name of the precache is, and only checks in that cache.
   * - It allows you to pass in an "original" URL without versioning parameters,
   * and it will automatically look up the correct cache key for the currently
   * active revision of that URL.
   *
   * E.g., `matchPrecache('index.html')` will find the correct precached
   * response for the currently active service worker, even if the actual cache
   * key is `'/index.html?__WB_REVISION__=1234abcd'`.
   *
   * @param {string|Request} request The key (without revisioning parameters)
   * to look up in the precache.
   * @return {Promise<Response|undefined>}
   */
  async matchPrecache(t) {
    const s = t instanceof Request ? t.url : t, a = this.getCacheKeyForURL(s);
    if (a)
      return (await self.caches.open(this.strategy.cacheName)).match(a);
  }
  /**
   * Returns a function that looks up `url` in the precache (taking into
   * account revision information), and returns the corresponding `Response`.
   *
   * @param {string} url The precached URL which will be used to lookup the
   * `Response`.
   * @return {workbox-routing~handlerCallback}
   */
  createHandlerBoundToURL(t) {
    const s = this.getCacheKeyForURL(t);
    if (!s)
      throw new u("non-precached-url", { url: t });
    return (a) => (a.request = new Request(t), a.params = Object.assign({ cacheKey: s }, a.params), this.strategy.handle(a));
  }
}
let C;
const N = () => (C || (C = new X()), C);
try {
  self["workbox:routing:6.5.3"] && _();
} catch {
}
const L = "GET", w = (i) => i && typeof i == "object" ? i : { handle: i };
class k {
  /**
   * Constructor for Route class.
   *
   * @param {workbox-routing~matchCallback} match
   * A callback function that determines whether the route matches a given
   * `fetch` event by returning a non-falsy value.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(t, s, a = L) {
    this.handler = w(s), this.match = t, this.method = a;
  }
  /**
   *
   * @param {workbox-routing-handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response
   */
  setCatchHandler(t) {
    this.catchHandler = w(t);
  }
}
class Y extends k {
  /**
   * If the regular expression contains
   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
   * the captured values will be passed to the
   * {@link workbox-routing~handlerCallback} `params`
   * argument.
   *
   * @param {RegExp} regExp The regular expression to match against URLs.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(t, s, a) {
    const n = ({ url: o }) => {
      const c = t.exec(o.href);
      if (c && !(o.origin !== location.origin && c.index !== 0))
        return c.slice(1);
    };
    super(n, s, a);
  }
}
class ee {
  /**
   * Initializes a new Router.
   */
  constructor() {
    this._routes = /* @__PURE__ */ new Map(), this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  /**
   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
   * method name ('GET', etc.) to an array of all the corresponding `Route`
   * instances that are registered.
   */
  get routes() {
    return this._routes;
  }
  /**
   * Adds a fetch event listener to respond to events when a route matches
   * the event's request.
   */
  addFetchListener() {
    self.addEventListener("fetch", (t) => {
      const { request: s } = t, a = this.handleRequest({ request: s, event: t });
      a && t.respondWith(a);
    });
  }
  /**
   * Adds a message event listener for URLs to cache from the window.
   * This is useful to cache resources loaded on the page prior to when the
   * service worker started controlling it.
   *
   * The format of the message data sent from the window should be as follows.
   * Where the `urlsToCache` array may consist of URL strings or an array of
   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
   *
   * ```
   * {
   *   type: 'CACHE_URLS',
   *   payload: {
   *     urlsToCache: [
   *       './script1.js',
   *       './script2.js',
   *       ['./script3.js', {mode: 'no-cors'}],
   *     ],
   *   },
   * }
   * ```
   */
  addCacheListener() {
    self.addEventListener("message", (t) => {
      if (t.data && t.data.type === "CACHE_URLS") {
        const { payload: s } = t.data, a = Promise.all(s.urlsToCache.map((n) => {
          typeof n == "string" && (n = [n]);
          const o = new Request(...n);
          return this.handleRequest({ request: o, event: t });
        }));
        t.waitUntil(a), t.ports && t.ports[0] && a.then(() => t.ports[0].postMessage(!0));
      }
    });
  }
  /**
   * Apply the routing rules to a FetchEvent object to get a Response from an
   * appropriate Route's handler.
   *
   * @param {Object} options
   * @param {Request} options.request The request to handle.
   * @param {ExtendableEvent} options.event The event that triggered the
   *     request.
   * @return {Promise<Response>|undefined} A promise is returned if a
   *     registered route can handle the request. If there is no matching
   *     route and there's no `defaultHandler`, `undefined` is returned.
   */
  handleRequest({ request: t, event: s }) {
    const a = new URL(t.url, location.href);
    if (!a.protocol.startsWith("http"))
      return;
    const n = a.origin === location.origin, { params: o, route: c } = this.findMatchingRoute({
      event: s,
      request: t,
      sameOrigin: n,
      url: a
    });
    let r = c && c.handler;
    const l = t.method;
    if (!r && this._defaultHandlerMap.has(l) && (r = this._defaultHandlerMap.get(l)), !r)
      return;
    let h;
    try {
      h = r.handle({ url: a, request: t, event: s, params: o });
    } catch (m) {
      h = Promise.reject(m);
    }
    const g = c && c.catchHandler;
    return h instanceof Promise && (this._catchHandler || g) && (h = h.catch(async (m) => {
      if (g)
        try {
          return await g.handle({ url: a, request: t, event: s, params: o });
        } catch (v) {
          v instanceof Error && (m = v);
        }
      if (this._catchHandler)
        return this._catchHandler.handle({ url: a, request: t, event: s });
      throw m;
    })), h;
  }
  /**
   * Checks a request and URL (and optionally an event) against the list of
   * registered routes, and if there's a match, returns the corresponding
   * route along with any params generated by the match.
   *
   * @param {Object} options
   * @param {URL} options.url
   * @param {boolean} options.sameOrigin The result of comparing `url.origin`
   *     against the current origin.
   * @param {Request} options.request The request to match.
   * @param {Event} options.event The corresponding event.
   * @return {Object} An object with `route` and `params` properties.
   *     They are populated if a matching route was found or `undefined`
   *     otherwise.
   */
  findMatchingRoute({ url: t, sameOrigin: s, request: a, event: n }) {
    const o = this._routes.get(a.method) || [];
    for (const c of o) {
      let r;
      const l = c.match({ url: t, sameOrigin: s, request: a, event: n });
      if (l)
        return r = l, (Array.isArray(r) && r.length === 0 || l.constructor === Object && // eslint-disable-line
        Object.keys(l).length === 0 || typeof l == "boolean") && (r = void 0), { route: c, params: r };
    }
    return {};
  }
  /**
   * Define a default `handler` that's called when no routes explicitly
   * match the incoming request.
   *
   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
   *
   * Without a default handler, unmatched requests will go against the
   * network as if there were no service worker present.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to associate with this
   * default handler. Each method has its own default.
   */
  setDefaultHandler(t, s = L) {
    this._defaultHandlerMap.set(s, w(t));
  }
  /**
   * If a Route throws an error while handling a request, this `handler`
   * will be called and given a chance to provide a response.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   */
  setCatchHandler(t) {
    this._catchHandler = w(t);
  }
  /**
   * Registers a route with the router.
   *
   * @param {workbox-routing.Route} route The route to register.
   */
  registerRoute(t) {
    this._routes.has(t.method) || this._routes.set(t.method, []), this._routes.get(t.method).push(t);
  }
  /**
   * Unregisters a route with the router.
   *
   * @param {workbox-routing.Route} route The route to unregister.
   */
  unregisterRoute(t) {
    if (!this._routes.has(t.method))
      throw new u("unregister-route-but-not-found-with-method", {
        method: t.method
      });
    const s = this._routes.get(t.method).indexOf(t);
    if (s > -1)
      this._routes.get(t.method).splice(s, 1);
    else
      throw new u("unregister-route-route-not-registered");
  }
}
let b;
const te = () => (b || (b = new ee(), b.addFetchListener(), b.addCacheListener()), b);
function se(i, t, s) {
  let a;
  if (typeof i == "string") {
    const o = new URL(i, location.href), c = ({ url: r }) => r.href === o.href;
    a = new k(c, t, s);
  } else if (i instanceof RegExp)
    a = new Y(i, t, s);
  else if (typeof i == "function")
    a = new k(i, t, s);
  else if (i instanceof k)
    a = i;
  else
    throw new u("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  return te().registerRoute(a), a;
}
function ae(i, t = []) {
  for (const s of [...i.searchParams.keys()])
    t.some((a) => a.test(s)) && i.searchParams.delete(s);
  return i;
}
function* ie(i, { ignoreURLParametersMatching: t = [/^utm_/, /^fbclid$/], directoryIndex: s = "index.html", cleanURLs: a = !0, urlManipulation: n } = {}) {
  const o = new URL(i, location.href);
  o.hash = "", yield o.href;
  const c = ae(o, t);
  if (yield c.href, s && c.pathname.endsWith("/")) {
    const r = new URL(c.href);
    r.pathname += s, yield r.href;
  }
  if (a) {
    const r = new URL(c.href);
    r.pathname += ".html", yield r.href;
  }
  if (n) {
    const r = n({ url: o });
    for (const l of r)
      yield l.href;
  }
}
class ne extends k {
  /**
   * @param {PrecacheController} precacheController A `PrecacheController`
   * instance used to both match requests and respond to fetch events.
   * @param {Object} [options] Options to control how requests are matched
   * against the list of precached URLs.
   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
   * check cache entries for a URLs ending with '/' to see if there is a hit when
   * appending the `directoryIndex` value.
   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
   * array of regex's to remove search params when looking for a cache match.
   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
   * check the cache for the URL with a `.html` added to the end of the end.
   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
   * This is a function that should take a URL and return an array of
   * alternative URLs that should be checked for precache matches.
   */
  constructor(t, s) {
    const a = ({ request: n }) => {
      const o = t.getURLsToCacheKeys();
      for (const c of ie(n.url, s)) {
        const r = o.get(c);
        if (r) {
          const l = t.getIntegrityForCacheKey(r);
          return { cacheKey: r, integrity: l };
        }
      }
    };
    super(a, t.strategy);
  }
}
function oe(i) {
  const t = N(), s = new ne(t, i);
  se(s);
}
const ce = "-precache-", re = async (i, t = ce) => {
  const a = (await self.caches.keys()).filter((n) => n.includes(t) && n.includes(self.registration.scope) && n !== i);
  return await Promise.all(a.map((n) => self.caches.delete(n))), a;
};
function le() {
  self.addEventListener("activate", (i) => {
    const t = y.getPrecacheName();
    i.waitUntil(re(t).then((s) => {
    }));
  });
}
function ue(i) {
  N().precache(i);
}
function he(i, t) {
  ue(i), oe(t);
}
console.log("Hello from service-worker.js", { build: x, files: T, prerendered: B, version: K });
const D = [...T, ...B, ...x].filter((i) => !i.endsWith(".jpeg") && !i.endsWith(".jpg") && !i.endsWith(".avif") && !i.endsWith(".webp") && !i.endsWith(".png") && !i.endsWith(".pdf")).filter((i) => !i.startsWith("/."));
console.log("Service worker urls: ", D);
he(
  D.map((i) => ({
    url: i,
    revision: K
  })),
  {
    cleanURLs: !1
  }
);
le();
self.addEventListener("install", () => {
  self.skipWaiting();
});
